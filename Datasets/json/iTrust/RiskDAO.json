[
    {
        "methods": [
            {
                "body": "Optional[{\r\n    List<FamilyMemberBean> familyMembers = getFamilyMembers(patientID);\r\n    for (FamilyMemberBean famMember : familyMembers) {\r\n        if (hadPriorDiagnoses(famMember.getMid(), icdLower, icdUpper))\r\n            return true;\r\n    }\r\n    return false;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public boolean hasFamilyHistory(long, double, double)",
                "comments": "Optional[/**\r\n * This method is implemented using {@link FamilyDAO} for 2 reasons: (a) definitions of family members\r\n * might change, so it's better to centralize that code and (2) to make this code a little bit \"nicer\"\r\n * even though it executes one query per family member. If this method gets slow, then you will need to\r\n * refactor. Otherwise, let's just keep it simple...\r\n *\r\n * @param patientID The MID of the patient in question.\r\n * @param icdLower A double of the lower bound for the codes.\r\n * @param icdUpper A double of the upper bound for the codes.\r\n * @return A boolean indicating whether a family member had a match in this range.\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Checks if the given patient has any family members with a history of prior diagnoses within a specified range of ICD codes.\n * \n * @param patientID The ID of the patient to check for family history\n * @param icdLower The lower bound of the range of ICD codes to search for in family members' prior diagnoses\n * @param icdUpper The upper bound of the range of ICD codes to search for in family members' prior diagnoses\n * @return true if any family member of the patient has a prior diagnosis within the specified range of ICD codes, false otherwise\n */"
            },
            {
                "body": "Optional[{\r\n    FamilyDAO famDAO = factory.getFamilyDAO();\r\n    List<FamilyMemberBean> familyMembers = famDAO.getParents(patientID);\r\n    familyMembers.addAll(famDAO.getSiblings(patientID));\r\n    return familyMembers;\r\n}]",
                "hasComment": false,
                "hasInnerComment": false,
                "signature": "private List<FamilyMemberBean> getFamilyMembers(long)",
                "comments": null,
                "innerComments": null,
                "generated_comment": "/**\n * Retrieves a list of family members for a given patient ID.\n * \n * @param patientID the ID of the patient whose family members are to be retrieved\n * @return a list of FamilyMemberBean objects representing the parents and siblings of the patient\n */\nprivate List<FamilyMemberBean> getFamilyMembers(long patientID) {\n    FamilyDAO famDAO = factory.getFamilyDAO();\n    List<FamilyMemberBean> familyMembers = famDAO.getParents(patientID);\n    familyMembers.addAll(famDAO.getSiblings(patientID));\n    return familyMembers;\n}"
            },
            {
                "body": "Optional[{\r\n    // Note the datediff call - this is a MySQL function that takes the difference between two\r\n    // dates and returns that value in terms of days. 6570 days is 18 years (not counting leap years)\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"SELECT * FROM OVDiagnosis ovd, OfficeVisits ov, Patients p \" + \"WHERE ovd.visitID=ov.id AND ov.patientid=p.mid AND p.mid=? \" + \"AND datediff(ov.visitdate,p.dateofbirth) < 6570 AND ovd.icdcode IN (\" + createPrepared(icdCodes.length) + \")\");\r\n        ps.setLong(1, patientID);\r\n        setICDs(2, ps, icdCodes);\r\n        // if this query has ANY rows, then yes\r\n        return ps.executeQuery().next();\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "public boolean hadChildhoodInfection(long, double...)",
                "comments": "Optional[/**\r\n * Returns whether or not a patient had a childhood infection for the exact, given ICD codes.\r\n *\r\n * @param patientID The MID of the patient in question.\r\n * @param icdCodes A parameter list of the ICD codes to match.\r\n * @return A boolean indicating whether this patient had all the listed ICD codes.\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": "Optional[[// Note the datediff call - this is a MySQL function that takes the difference between two\r\n, // dates and returns that value in terms of days. 6570 days is 18 years (not counting leap years)\r\n, // if this query has ANY rows, then yes\r\n]]",
                "generated_comment": "/**\n * Checks if a patient had a childhood infection based on their date of birth and a list of infection codes.\n * \n * @param patientID the ID of the patient to check for childhood infection\n * @param icdCodes an array of infection codes to check against\n * @return true if the patient had a childhood infection, false otherwise\n * @throws DBException if there is an error accessing the database\n */"
            },
            {
                "body": "Optional[{\r\n    String str = \"\";\r\n    for (int i = 0; i < length; i++) str += \"?,\";\r\n    return str.substring(0, str.length() - 1);\r\n}]",
                "hasComment": false,
                "hasInnerComment": false,
                "signature": "private String createPrepared(int)",
                "comments": null,
                "innerComments": null,
                "generated_comment": "/**\n * Creates a prepared statement string with the specified number of placeholders.\n * Each placeholder is represented by a question mark.\n * \n * @param length the number of placeholders to create\n * @return a string containing the placeholders separated by commas\n */"
            },
            {
                "body": "Optional[{\r\n    for (double icdCode : icdCodes) {\r\n        ps.setDouble(start++, icdCode);\r\n    }\r\n}]",
                "hasComment": false,
                "hasInnerComment": false,
                "signature": "private void setICDs(int, PreparedStatement, double[])",
                "comments": null,
                "innerComments": null,
                "generated_comment": "/**\n * Sets the specified array of ICD codes in the given PreparedStatement starting at the specified index.\n * \n * @param start the index at which to start setting the ICD codes in the PreparedStatement\n * @param ps the PreparedStatement to set the ICD codes in\n * @param icdCodes the array of ICD codes to set in the PreparedStatement\n */\nprivate void setICDs(int start, PreparedStatement ps, double[] icdCodes) {\n    for (double icdCode : icdCodes) {\n        ps.setDouble(start++, icdCode);\n    }\n} \n\n/**\n * Sets the specified array of ICD codes in the given PreparedStatement starting at the specified index.\n * \n * @param start the index at which to start setting the ICD codes in the PreparedStatement\n * @param ps the PreparedStatement to set the ICD codes in\n * @param icdCodes the array of ICD codes to set in the PreparedStatement\n */"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"SELECT * FROM PersonalHealthInformation WHERE PatientID=? AND Smoker=1\");\r\n        ps.setLong(1, patientID);\r\n        // if this query has ANY rows, then yes\r\n        return ps.executeQuery().next();\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "public boolean hasSmoked(long)",
                "comments": "Optional[/**\r\n * Returns if the patient has ever smoked in their life\r\n *\r\n * @param patientID The MID of the patient in question.\r\n * @return A boolean indicating whether the patient smoked.\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": "Optional[[// if this query has ANY rows, then yes\r\n]]",
                "generated_comment": "/**\n * Checks if a patient has a history of smoking based on their PatientID.\n * \n * @param patientID the unique identifier of the patient\n * @return true if the patient has a history of smoking, false otherwise\n * @throws DBException if there is an error accessing the database\n */"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"SELECT * FROM OVDiagnosis ovd, OfficeVisits ov, Patients p \" + \"WHERE ovd.visitID=ov.id AND ov.patientid=p.mid AND p.mid=? \" + \"AND ovd.icdcode>=? AND ovd.icdcode<?\");\r\n        ps.setLong(1, patientID);\r\n        ps.setDouble(2, lowerICDCode);\r\n        ps.setDouble(3, upperICDCode);\r\n        // if this query has ANY rows, then yes\r\n        return ps.executeQuery().next();\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "public boolean hadPriorDiagnoses(long, double, double)",
                "comments": "Optional[/**\r\n * Returns if a patient has ever been diagnosed with the given ICD code, in the range [lower,upper)\r\n *\r\n * @param patientID The MID of the patient in question.\r\n * @param lowerICDCode A double of the lower ICD code.\r\n * @param upperICDCode A double of the upper ICD code.\r\n * @return A boolean indicating whether there was a match in the given range.\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": "Optional[[// if this query has ANY rows, then yes\r\n]]",
                "generated_comment": "/**\n * Checks if a patient has had prior diagnoses with ICD codes falling within a specified range.\n * \n * @param patientID the ID of the patient to check for prior diagnoses\n * @param lowerICDCode the lower bound of the ICD code range to search for\n * @param upperICDCode the upper bound of the ICD code range to search for\n * @return true if the patient has had prior diagnoses within the specified ICD code range, false otherwise\n * @throws DBException if there is an error accessing the database\n */"
            }
        ],
        "constructors": [
            {
                "body": "{\r\n    this.factory = factory;\r\n}",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public RiskDAO(DAOFactory)",
                "comments": "Optional[/**\r\n * The typical constructor.\r\n * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Constructs a new RiskDAO with the specified DAOFactory.\n * \n * @param factory the DAOFactory used to create data access objects\n * \n * Initializes the RiskDAO with the given DAOFactory, allowing it to create data access objects for interacting with the database.\n */"
            }
        ],
        "signature": "RiskDAO",
        "variables": [
            "private DAOFactory factory"
        ],
        "generated_class_comment": "/**\n * The FamilyHistoryChecker class provides methods for checking the family history of a patient for prior diagnoses within a specified range of ICD codes.\n * \n * This class utilizes the FamilyDAO to retrieve family members and their prior diagnoses. The main functionality of this class is to determine if any family member of a patient has a prior diagnosis within a specified range of ICD codes.\n * \n * The hasFamilyHistory method takes the patient's ID, lower and upper bounds of the ICD code range, and returns a boolean indicating whether any family member had a match in this range.\n * \n * The getFamilyMembersWithPriorDiagnoses method retrieves a list of family members (parents and siblings) of the patient who have prior diagnoses.\n * \n * This class is designed to centralize the code for checking family history and to provide a simple and efficient way to determine if a patient has any family members with a history of prior diagnoses within a specified range of ICD codes.\n */\n**/\n/**\n * This class contains methods for retrieving family members and determining if a patient had a childhood infection.\n * \n * The method getFamilyMembers(long patientID) retrieves a list of family members for a given patient ID. It first obtains the parents of the patient from the FamilyDAO and then adds the siblings to the list of family members. The method returns a list of FamilyMemberBean objects representing the parents and siblings of the patient.\n * \n * The method hadChildhoodInfection(long patientID, double... icdCodes) checks if a patient had a childhood infection for the exact, given ICD codes. It executes a SQL query to find any instances where the patient had a childhood infection based on the provided ICD codes. The method returns a boolean value indicating whether the patient had a childhood infection for the specified ICD codes.\n */\npublic class FamilyUtils {\n    private List<FamilyMemberBean> getFamilyMembers(long patientID) {\n        FamilyDAO famDAO = factory.getFamilyDAO();\n        List<FamilyMemberBean> familyMembers = famDAO.getParents(patientID);\n        familyMembers.addAll(famDAO.getSiblings(patientID));\n        return familyMembers;\n    }\n\n    public boolean hadChildhoodInfection(long patientID, double... icdCodes) {\n        // Note the datediff call - this is a MySQL function that takes the difference between two\n        // dates and returns that value in terms of days. 6570 days is 18 years (not counting leap years)\n        Connection conn = null;\n        PreparedStatement ps = null;\n        try {\n            conn = factory.getConnection();\n            ps = conn.prepareStatement(\"SELECT * FROM OVDiagnosis ovd, OfficeVisits ov, Patients p \" + \"WHERE ovd.visitID=ov.id AND ov.patientid=p.mid AND p.mid=? \" + \"AND datediff(ov.visitdate,p.dateofbirth) < 6570 AND ovd.icdcode IN (\" + createPrepared(icdCodes.length) + \")\");\n            ps.setLong(1, patientID);\n            setICDs(2, ps, icdCodes);\n            // if this query has ANY rows, then yes\n            return ps.executeQuery().next();\n        } catch (SQLException e) {\n            e.printStackTrace();\n            throw new DBException(e);\n        } finally {\n            DBUtil.closeConnection(conn, ps);\n        }\n    }\n}\n*/\n/**\n * This class provides methods for checking if a patient had a childhood infection based on their date of birth and a list of infection codes.\n * It includes functionality to create a prepared statement string with a specified number of placeholders and set ICD codes in a PreparedStatement.\n * \n * The main functionalities of this class are:\n * 1. Checking if a patient had a childhood infection based on date of birth and infection codes.\n * 2. Creating a prepared statement string with a specified number of placeholders.\n * 3. Setting ICD codes in a PreparedStatement.\n * \n * The behavior of this class is to interact with a database to retrieve information about a patient's childhood infection status.\n * It handles exceptions that may occur during database access and provides methods to perform the necessary operations.\n * \n * @throws DBException if there is an error accessing the database\n */\n**/\nSure! Here is a comprehensive JavaDoc comment for the class:\n\n/**\n * This class contains utility methods for setting and retrieving ICD codes in a PreparedStatement.\n * It provides methods for setting an array of ICD codes starting at a specified index in the PreparedStatement.\n * Additionally, it includes a method to check if a patient has ever smoked based on their PatientID.\n * \n * The setICDs method allows for setting an array of ICD codes in a PreparedStatement starting at a specified index.\n * The hasSmoked method checks if a patient has a history of smoking based on their PatientID.\n * \n * This class handles database connections, PreparedStatement creation, and exception handling for database operations.\n * \n * Note: Make sure to handle database connections and exceptions appropriately when using these methods.\n */\n \nThis JavaDoc comment describes the purpose of the class, its main functionalities, and its overall behavior.\n/**\n * The RiskDAO class is responsible for handling database operations related to patient risk assessments.\n * It provides methods for checking if a patient has had prior diagnoses with ICD codes falling within a specified range.\n * \n * This class utilizes a DAOFactory for obtaining SQL connections and other resources necessary for database operations.\n * \n * The main functionality of this class is to determine if a patient has had prior diagnoses within a specified ICD code range.\n * It achieves this by querying the database for relevant information and returning a boolean result.\n * \n * Overall, the RiskDAO class serves as a bridge between the application and the database, facilitating the retrieval\n * of patient risk assessment data and providing essential functionality for assessing patient health risks.\n * \n * @author [Your Name]\n * @version 1.0\n */\n/**\n * The RiskDAO class represents a data access object for interacting with the database in the context of risk management.\n * It is responsible for handling CRUD operations related to risks, such as creating, reading, updating, and deleting risk data.\n * \n * This class is initialized with a DAOFactory, which is used to create data access objects for interacting with the database.\n * \n * The main functionalities of the RiskDAO class include:\n * - Creating new risk entries in the database\n * - Retrieving existing risk data from the database\n * - Updating risk information in the database\n * - Deleting risk entries from the database\n * \n * By using the methods provided by this class, users can effectively manage risk data and ensure the accuracy and integrity of their risk management processes.\n */"
    }
]