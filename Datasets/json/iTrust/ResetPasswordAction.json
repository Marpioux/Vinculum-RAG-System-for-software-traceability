[
    {
        "methods": [
            {
                "body": "Optional[{\r\n    try {\r\n        long mid = Long.valueOf(midString);\r\n        if (!authDAO.checkUserExists(mid))\r\n            return 0;\r\n        return mid;\r\n    } catch (NumberFormatException e) {\r\n        return 0L;\r\n    } catch (DBException e) {\r\n        return 0L;\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public long checkMID(String)",
                "comments": "Optional[/**\r\n * Checks to see if a user exists with the given mid\r\n *\r\n * @param midString The user's MID to check for.\r\n * @return 0 if the user does not exist, else the mid of the user as a long\r\n */\r\n]",
                "innerComments": null
            },
            {
                "body": "Optional[{\r\n    return authDAO.getResetPasswordFailures(ipAddress) >= MAX_RESET_ATTEMPTS;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public boolean isMaxedOut(String)",
                "comments": "Optional[/**\r\n * Checks to see if the number of reset password attempts has been exceeded for the given ipAddress\r\n *\r\n * @param ipAddress The IPv4 or IPv6 IP address as a String.\r\n * @return true if the the number of reset attempts is greater than or equal to MAX_RESET_ATTEMPTS\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": null
            },
            {
                "body": "Optional[{\r\n    try {\r\n        if ((\"patient\".equals(role) && patientDAO.getRole(mid, role).equals(\"patient\")) || (\"hcp\".equals(role) && patientDAO.getRole(mid, role).equals(\"hcp\")) || (\"uap\".equals(role) && patientDAO.getRole(mid, role).equals(\"uap\")) || (\"pha\".equals(role) && patientDAO.getRole(mid, role).equals(\"pha\")) || (\"er\".equals(role) && patientDAO.getRole(mid, role).equals(\"er\")))\r\n            return role;\r\n        else\r\n            return null;\r\n    } catch (DBException e) {\r\n        e.printStackTrace();\r\n    } catch (iTrustException e) {\r\n        e.printStackTrace();\r\n        throw e;\r\n    }\r\n    return null;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public String checkRole(long, String)",
                "comments": "Optional[/**\r\n * Checks if the given mid matches the given role\r\n *\r\n * @param mid\r\n *            the mid to be checked\r\n * @param role\r\n *            the role to be checked\r\n * @return true if the mid and role match\r\n * @throws iTrustException\r\n */\r\n]",
                "innerComments": null
            },
            {
                "body": "Optional[{\r\n    if (answer == null || \"\".equals(answer))\r\n        return null;\r\n    else\r\n        return answer;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public String checkAnswerNull(String)",
                "comments": "Optional[/**\r\n * Checks if the answer param is null\r\n *\r\n * @param answer the user's security answer\r\n * @return answer if not null, else return null\r\n */\r\n]",
                "innerComments": null
            },
            {
                "body": "Optional[{\r\n    try {\r\n        if (null == authDAO.getSecurityQuestion(mid) || authDAO.getSecurityQuestion(mid).equals(\"\"))\r\n            throw new iTrustException(\"No security question or answer for this user has been set.\");\r\n        else\r\n            return authDAO.getSecurityQuestion(mid);\r\n    } catch (DBException e) {\r\n        e.printStackTrace();\r\n        return \"\";\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public String getSecurityQuestion(long)",
                "comments": "Optional[/**\r\n * Returns the security question for the mid param\r\n *\r\n * @param mid MID of the user\r\n * @return the security question or \"\" if DBException thrown\r\n * @throws iTrustException\r\n */\r\n]",
                "innerComments": null
            },
            {
                "body": "Optional[{\r\n    Role r = authDAO.getUserRole(mid);\r\n    try {\r\n        Role.parse(role);\r\n    } catch (IllegalArgumentException e) {\r\n        return \"Invalid role\";\r\n    }\r\n    if (r.equals(Role.ADMIN))\r\n        return \"This role cannot be changed here\";\r\n    if (!r.equals(Role.parse(role)))\r\n        return \"Role mismatch\";\r\n    if (authDAO.getResetPasswordFailures(ipAddr) >= MAX_RESET_ATTEMPTS) {\r\n        return \"Too many retries\";\r\n    }\r\n    try {\r\n        validatePassword(password, confirmPassword);\r\n        if (answer.equals(authDAO.getSecurityAnswer(mid))) {\r\n            authDAO.resetPassword(mid, password);\r\n            new EmailUtil(factory).sendEmail(makeEmailApp(mid, role));\r\n            return \"Password changed\";\r\n        } else {\r\n            authDAO.recordResetPasswordFailure(ipAddr);\r\n            return \"Answer did not match\";\r\n        }\r\n    } catch (DBException e) {\r\n        return \"Error in validation of security answer\";\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public String resetPassword(long, String, String, String, String, String)",
                "comments": "Optional[/**\r\n * Resets the password for the given mid\r\n *\r\n * @param mid of the user to have their password reset\r\n * @param role what role the user has in iTrust\r\n * @param answer answers to their security question\r\n * @param password their password\r\n * @param confirmPassword their password again\r\n * @param ipAddr the ip address the request is coming from\r\n * @return status message\r\n * @throws FormValidationException\r\n * @throws DBException\r\n * @throws iTrustException\r\n */\r\n]",
                "innerComments": null
            },
            {
                "body": "Optional[{\r\n    if (Role.parse(role) == Role.PATIENT) {\r\n        PatientBean p = new PatientDAO(factory).getPatient(mid);\r\n        Email email = new Email();\r\n        email.setFrom(\"no-reply@itrust.com\");\r\n        email.setToList(Arrays.asList(p.getEmail()));\r\n        email.setSubject(\"Your password has been changed in iTrust\");\r\n        email.setBody(String.format(\"Dear %s, \\n You have chosen to change your iTrust password for user %s\", p.getFullName(), mid));\r\n        return email;\r\n    } else {\r\n        //UAP or HCP - admin taken out in \"resetPassword\"\r\n        PersonnelBean p = new PersonnelDAO(factory).getPersonnel(mid);\r\n        Email email = new Email();\r\n        email.setFrom(\"no-reply@itrust.com\");\r\n        email.setToList(Arrays.asList(p.getEmail()));\r\n        email.setSubject(\"Your password has been changed in iTrust\");\r\n        email.setBody(String.format(\"Dear %s, \\n You have chosen to change your iTrust password for user %s\", p.getFullName(), mid));\r\n        return email;\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "private Email makeEmailApp(long, String)",
                "comments": "Optional[/**\r\n * Creates and sends an e-mail about the change\r\n *\r\n * @param mid the user who's password was changed\r\n * @param role what role they have in iTrust\r\n * @return the e-mial that is sent\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": "Optional[[//UAP or HCP - admin taken out in \"resetPassword\"\r\n]]"
            },
            {
                "body": "Optional[{\r\n    ErrorList errorList = new ErrorList();\r\n    if (password == null || \"\".equals(password)) {\r\n        errorList.addIfNotNull(\"Password cannot be empty\");\r\n    } else {\r\n        if (!password.equals(confirmPassword))\r\n            errorList.addIfNotNull(\"Passwords don't match\");\r\n        if (!ValidationFormat.PASSWORD.getRegex().matcher(password).matches()) {\r\n            errorList.addIfNotNull(\"Password must be in the following format: \" + ValidationFormat.PASSWORD.getDescription());\r\n        }\r\n    }\r\n    if (errorList.hasErrors())\r\n        throw new FormValidationException(errorList);\r\n}]",
                "hasComment": false,
                "hasInnerComment": false,
                "signature": "private void validatePassword(String, String)",
                "comments": null,
                "innerComments": null
            }
        ],
        "constructors": [
            {
                "body": "{\r\n    this.authDAO = factory.getAuthDAO();\r\n    this.patientDAO = factory.getPatientDAO();\r\n    this.factory = factory;\r\n}",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public ResetPasswordAction(DAOFactory)",
                "comments": "Optional[/**\r\n * Set up defaults\r\n * @param factory The DAOFactory used to create the DAOs used in this action.\r\n */\r\n]",
                "innerComments": null
            }
        ],
        "signature": "ResetPasswordAction",
        "variables": [
            "public  static  final int MAX_RESET_ATTEMPTS",
            "private AuthDAO authDAO",
            "private PatientDAO patientDAO",
            "private DAOFactory factory"
        ]
    }
]