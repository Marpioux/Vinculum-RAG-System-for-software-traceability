[
    {
        "methods": [
            {
                "body": "Optional[{\r\n    return send;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public List<ApptBean> getSend()",
                "comments": "Optional[/**\r\n * Return the send request for an AppointmentBean\r\n * @return the send request for an AppointmentBean\r\n */\r\n]",
                "innerComments": null
            },
            {
                "body": "Optional[{\r\n    boolean[] conflicts = new boolean[send.size()];\r\n    for (int i = 0; i < send.size(); i++) {\r\n        ApptBean ab = send.get(i);\r\n        long t = ab.getDate().getTime();\r\n        long m = types.getDurationByType(ab.getApptType()) * 60L * 1000L;\r\n        Timestamp time = new Timestamp(t + m);\r\n        for (int j = i + 1; j < send.size(); j++) {\r\n            if (send.get(j).getDate().before(time)) {\r\n                conflicts[i] = true;\r\n                conflicts[j] = true;\r\n            }\r\n        }\r\n    }\r\n    return conflicts;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public boolean[] getConflicts()",
                "comments": "Optional[/**\r\n * Check appointments appearing on the calendar for conflicts\r\n * with other appointments on the calendar.\r\n *\r\n * The array from this method is used to determine what appointments\r\n * will appear in bold on the calendar.\r\n *\r\n * @return An array of items that are in conflict with other items.\r\n * @throws SQLException\r\n */\r\n]",
                "innerComments": null
            },
            {
                "body": "Optional[{\r\n    List<ApptBean> appts = a_action.getMyAppointments();\r\n    Hashtable<Integer, ArrayList<ApptBean>> atable = new Hashtable<Integer, ArrayList<ApptBean>>();\r\n    Calendar a = Calendar.getInstance();\r\n    for (ApptBean b : appts) {\r\n        a.setTimeInMillis(b.getDate().getTime());\r\n        if (a.get(Calendar.MONTH) == thisMonth && a.get(Calendar.YEAR) == thisYear) {\r\n            if (!atable.containsKey(a.get(Calendar.DAY_OF_MONTH)))\r\n                atable.put(a.get(Calendar.DAY_OF_MONTH), new ArrayList<ApptBean>());\r\n            ArrayList<ApptBean> l = atable.get(a.get(Calendar.DAY_OF_MONTH));\r\n            l.add(b);\r\n            send.add(b);\r\n            atable.put(a.get(Calendar.DAY_OF_MONTH), l);\r\n        }\r\n    }\r\n    return atable;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public Hashtable<Integer, ArrayList<ApptBean>> getApptsTable(int, int)",
                "comments": "Optional[/**\r\n * Creates a hash table with all of the Appointments to be\r\n * displayed on the calendar for the month and year being viewed.\r\n *\r\n * @param thisMonth The month of the calendar to be rendered\r\n * @param thisYear The year of the calendar to be rendered\r\n * @return A Hashtable containing the AppointmentBeans to be rendered\r\n * @throws SQLException\r\n */\r\n]",
                "innerComments": null
            },
            {
                "body": "Optional[{\r\n    List<OfficeVisitBean> officeVisits = r_action.getAllOfficeVisits();\r\n    Hashtable<Integer, ArrayList<OfficeVisitBean>> rtable = new Hashtable<Integer, ArrayList<OfficeVisitBean>>();\r\n    Calendar a = Calendar.getInstance();\r\n    for (OfficeVisitBean b : officeVisits) {\r\n        a.setTimeInMillis(b.getVisitDate().getTime());\r\n        if (a.get(Calendar.MONTH) == thisMonth && a.get(Calendar.YEAR) == thisYear) {\r\n            if (!rtable.containsKey(a.get(Calendar.DAY_OF_MONTH)))\r\n                rtable.put(a.get(Calendar.DAY_OF_MONTH), new ArrayList<OfficeVisitBean>());\r\n            ArrayList<OfficeVisitBean> l = rtable.get(a.get(Calendar.DAY_OF_MONTH));\r\n            l.add(b);\r\n            rtable.put(a.get(Calendar.DAY_OF_MONTH), l);\r\n        }\r\n    }\r\n    return rtable;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public Hashtable<Integer, ArrayList<OfficeVisitBean>> getOfficeVisitsTable(int, int)",
                "comments": "Optional[/**\r\n * Creates a hash table with all of the Office Visits to be\r\n * displayed on the calendar for the month and year being viewed.\r\n *\r\n * @param thisMonth The month of the calendar to be rendered\r\n * @param thisYear The year of the calendar to be rendered\r\n * @return A Hashtable containing the OfficeVisitBeans to be rendered\r\n * @throws SQLException\r\n */\r\n]",
                "innerComments": null
            },
            {
                "body": "Optional[{\r\n    List<LabProcedureBean> procs = r_action.getLabs();\r\n    Hashtable<Integer, ArrayList<LabProcedureBean>> ptable = new Hashtable<Integer, ArrayList<LabProcedureBean>>();\r\n    Calendar a = Calendar.getInstance();\r\n    for (LabProcedureBean b : procs) {\r\n        a.setTimeInMillis(b.getTimestamp().getTime());\r\n        if (a.get(Calendar.MONTH) == thisMonth && a.get(Calendar.YEAR) == thisYear) {\r\n            if (!ptable.containsKey(a.get(Calendar.DAY_OF_MONTH)))\r\n                ptable.put(a.get(Calendar.DAY_OF_MONTH), new ArrayList<LabProcedureBean>());\r\n            ArrayList<LabProcedureBean> l = ptable.get(a.get(Calendar.DAY_OF_MONTH));\r\n            l.add(b);\r\n            ptable.put(a.get(Calendar.DAY_OF_MONTH), l);\r\n        }\r\n    }\r\n    return ptable;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public Hashtable<Integer, ArrayList<LabProcedureBean>> getLabProceduresTable(int, int)",
                "comments": "Optional[/**\r\n * Creates a hash table with all of the lab procedures to be\r\n * displayed on the calendar for the month and year being viewed.\r\n *\r\n * @param thisMonth The month of the calendar to be rendered\r\n * @param thisYear The year of the calendar to be rendered\r\n * @return A Hashtable containing the LabProcedureBeans to be rendered\r\n * @throws SQLException\r\n */\r\n]",
                "innerComments": null
            }
        ],
        "constructors": [
            {
                "body": "{\r\n    a_action = new ViewMyApptsAction(factory, loggedInMID);\r\n    types = new EditApptTypeAction(factory, loggedInMID);\r\n    r_action = new ViewMyRecordsAction(factory, loggedInMID);\r\n    send = new ArrayList<ApptBean>();\r\n}",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public GenerateCalendarAction(DAOFactory, long)",
                "comments": "Optional[/**\r\n * Set up defaults\r\n *\r\n * @param factory The DAOFactory used to create the DAOs used in this action.\r\n * @param loggedInMID The MID of the user who is viewing the calendar\r\n */\r\n]",
                "innerComments": null
            }
        ],
        "signature": "GenerateCalendarAction",
        "variables": [
            "private ViewMyApptsAction a_action",
            "private EditApptTypeAction types",
            "private ViewMyRecordsAction r_action",
            "private List<ApptBean> send"
        ]
    }
]