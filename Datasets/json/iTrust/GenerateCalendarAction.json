[
    {
        "methods": [
            {
                "body": "Optional[{\r\n    return send;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public List<ApptBean> getSend()",
                "comments": "Optional[/**\r\n * Return the send request for an AppointmentBean\r\n * @return the send request for an AppointmentBean\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Retrieves a list of appointments that are scheduled to be sent.\n * \n * @return a List of ApptBean objects representing appointments that are scheduled to be sent\n */"
            },
            {
                "body": "Optional[{\r\n    boolean[] conflicts = new boolean[send.size()];\r\n    for (int i = 0; i < send.size(); i++) {\r\n        ApptBean ab = send.get(i);\r\n        long t = ab.getDate().getTime();\r\n        long m = types.getDurationByType(ab.getApptType()) * 60L * 1000L;\r\n        Timestamp time = new Timestamp(t + m);\r\n        for (int j = i + 1; j < send.size(); j++) {\r\n            if (send.get(j).getDate().before(time)) {\r\n                conflicts[i] = true;\r\n                conflicts[j] = true;\r\n            }\r\n        }\r\n    }\r\n    return conflicts;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public boolean[] getConflicts()",
                "comments": "Optional[/**\r\n * Check appointments appearing on the calendar for conflicts\r\n * with other appointments on the calendar.\r\n *\r\n * The array from this method is used to determine what appointments\r\n * will appear in bold on the calendar.\r\n *\r\n * @return An array of items that are in conflict with other items.\r\n * @throws SQLException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Returns an array of booleans indicating whether there are conflicts between appointments in the given list.\n * A conflict is considered to occur if the end time of one appointment overlaps with the start time of another appointment.\n * \n * @return an array of booleans where each element represents whether there is a conflict at the corresponding index in the 'send' list\n */"
            },
            {
                "body": "Optional[{\r\n    List<ApptBean> appts = a_action.getMyAppointments();\r\n    Hashtable<Integer, ArrayList<ApptBean>> atable = new Hashtable<Integer, ArrayList<ApptBean>>();\r\n    Calendar a = Calendar.getInstance();\r\n    for (ApptBean b : appts) {\r\n        a.setTimeInMillis(b.getDate().getTime());\r\n        if (a.get(Calendar.MONTH) == thisMonth && a.get(Calendar.YEAR) == thisYear) {\r\n            if (!atable.containsKey(a.get(Calendar.DAY_OF_MONTH)))\r\n                atable.put(a.get(Calendar.DAY_OF_MONTH), new ArrayList<ApptBean>());\r\n            ArrayList<ApptBean> l = atable.get(a.get(Calendar.DAY_OF_MONTH));\r\n            l.add(b);\r\n            send.add(b);\r\n            atable.put(a.get(Calendar.DAY_OF_MONTH), l);\r\n        }\r\n    }\r\n    return atable;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public Hashtable<Integer, ArrayList<ApptBean>> getApptsTable(int, int)",
                "comments": "Optional[/**\r\n * Creates a hash table with all of the Appointments to be\r\n * displayed on the calendar for the month and year being viewed.\r\n *\r\n * @param thisMonth The month of the calendar to be rendered\r\n * @param thisYear The year of the calendar to be rendered\r\n * @return A Hashtable containing the AppointmentBeans to be rendered\r\n * @throws SQLException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Retrieves a Hashtable containing appointments for a specified month and year.\n * \n * @param thisMonth the month for which to retrieve appointments\n * @param thisYear the year for which to retrieve appointments\n * @return a Hashtable<Integer, ArrayList<ApptBean>> containing appointments for the specified month and year\n * \n * This method retrieves appointments from a given action class and filters them based on the specified month and year. \n * It then organizes the appointments into a Hashtable where the key is the day of the month and the value is a list of appointments for that day.\n * If no appointments exist for a particular day, an empty list is created. \n * The method returns the Hashtable containing the filtered appointments.\n */"
            },
            {
                "body": "Optional[{\r\n    List<OfficeVisitBean> officeVisits = r_action.getAllOfficeVisits();\r\n    Hashtable<Integer, ArrayList<OfficeVisitBean>> rtable = new Hashtable<Integer, ArrayList<OfficeVisitBean>>();\r\n    Calendar a = Calendar.getInstance();\r\n    for (OfficeVisitBean b : officeVisits) {\r\n        a.setTimeInMillis(b.getVisitDate().getTime());\r\n        if (a.get(Calendar.MONTH) == thisMonth && a.get(Calendar.YEAR) == thisYear) {\r\n            if (!rtable.containsKey(a.get(Calendar.DAY_OF_MONTH)))\r\n                rtable.put(a.get(Calendar.DAY_OF_MONTH), new ArrayList<OfficeVisitBean>());\r\n            ArrayList<OfficeVisitBean> l = rtable.get(a.get(Calendar.DAY_OF_MONTH));\r\n            l.add(b);\r\n            rtable.put(a.get(Calendar.DAY_OF_MONTH), l);\r\n        }\r\n    }\r\n    return rtable;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public Hashtable<Integer, ArrayList<OfficeVisitBean>> getOfficeVisitsTable(int, int)",
                "comments": "Optional[/**\r\n * Creates a hash table with all of the Office Visits to be\r\n * displayed on the calendar for the month and year being viewed.\r\n *\r\n * @param thisMonth The month of the calendar to be rendered\r\n * @param thisYear The year of the calendar to be rendered\r\n * @return A Hashtable containing the OfficeVisitBeans to be rendered\r\n * @throws SQLException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Retrieves a Hashtable mapping integer day values to lists of OfficeVisitBean objects for office visits that occurred in the specified month and year.\n * \n * @param thisMonth the month value to filter office visits by\n * @param thisYear the year value to filter office visits by\n * @return a Hashtable<Integer, ArrayList<OfficeVisitBean>> containing day values as keys and lists of OfficeVisitBean objects as values\n */"
            },
            {
                "body": "Optional[{\r\n    List<LabProcedureBean> procs = r_action.getLabs();\r\n    Hashtable<Integer, ArrayList<LabProcedureBean>> ptable = new Hashtable<Integer, ArrayList<LabProcedureBean>>();\r\n    Calendar a = Calendar.getInstance();\r\n    for (LabProcedureBean b : procs) {\r\n        a.setTimeInMillis(b.getTimestamp().getTime());\r\n        if (a.get(Calendar.MONTH) == thisMonth && a.get(Calendar.YEAR) == thisYear) {\r\n            if (!ptable.containsKey(a.get(Calendar.DAY_OF_MONTH)))\r\n                ptable.put(a.get(Calendar.DAY_OF_MONTH), new ArrayList<LabProcedureBean>());\r\n            ArrayList<LabProcedureBean> l = ptable.get(a.get(Calendar.DAY_OF_MONTH));\r\n            l.add(b);\r\n            ptable.put(a.get(Calendar.DAY_OF_MONTH), l);\r\n        }\r\n    }\r\n    return ptable;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public Hashtable<Integer, ArrayList<LabProcedureBean>> getLabProceduresTable(int, int)",
                "comments": "Optional[/**\r\n * Creates a hash table with all of the lab procedures to be\r\n * displayed on the calendar for the month and year being viewed.\r\n *\r\n * @param thisMonth The month of the calendar to be rendered\r\n * @param thisYear The year of the calendar to be rendered\r\n * @return A Hashtable containing the LabProcedureBeans to be rendered\r\n * @throws SQLException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Retrieves a Hashtable mapping day of the month to a list of LabProcedureBeans for the current month and year.\n * \n * @param thisMonth the current month\n * @param thisYear the current year\n * @return a Hashtable<Integer, ArrayList<LabProcedureBean>> containing LabProcedureBeans for each day of the month\n */"
            }
        ],
        "constructors": [
            {
                "body": "{\r\n    a_action = new ViewMyApptsAction(factory, loggedInMID);\r\n    types = new EditApptTypeAction(factory, loggedInMID);\r\n    r_action = new ViewMyRecordsAction(factory, loggedInMID);\r\n    send = new ArrayList<ApptBean>();\r\n}",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public GenerateCalendarAction(DAOFactory, long)",
                "comments": "Optional[/**\r\n * Set up defaults\r\n *\r\n * @param factory The DAOFactory used to create the DAOs used in this action.\r\n * @param loggedInMID The MID of the user who is viewing the calendar\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Constructs a new GenerateCalendarAction object with the specified DAOFactory and loggedInMID.\n * This constructor initializes three actions: ViewMyApptsAction, EditApptTypeAction, and ViewMyRecordsAction,\n * using the provided DAOFactory and loggedInMID. It also initializes an empty ArrayList of ApptBean objects.\n * \n * @param factory the DAOFactory used to interact with the database\n * @param loggedInMID the ID of the currently logged in user\n */"
            }
        ],
        "signature": "GenerateCalendarAction",
        "variables": [
            "private ViewMyApptsAction a_action",
            "private EditApptTypeAction types",
            "private ViewMyRecordsAction r_action",
            "private List<ApptBean> send"
        ],
        "generated_class_comment": "public class AppointmentManager {\n\n    /**\n     * Manages appointments and conflicts on a calendar.\n     * This class provides methods to retrieve send requests for appointments,\n     * check for conflicts between appointments, and manage a list of appointments.\n     */\n    \n    private List<ApptBean> send;\n    private Map<String, Integer> types;\n\n    /**\n     * Constructs an AppointmentManager with an initial list of appointments.\n     * \n     * @param send a List of ApptBean objects representing appointments\n     */\n    public AppointmentManager(List<ApptBean> send) {\n        this.send = send;\n        this.types = new HashMap<>();\n    }\n\n    /**\n     * Return the send request for an AppointmentBean\n     * \n     * @return the send request for an AppointmentBean\n     */\n    public List<ApptBean> getSend() {\n        return send;\n    }\n\n    /**\n     * Retrieves a list of appointments that are scheduled to be sent.\n     * \n     * @return a List of ApptBean objects representing appointments that are scheduled to be sent\n     */\n    \n    /**\n     * Check appointments appearing on the calendar for conflicts\n     * with other appointments on the calendar.\n     * \n     * The array from this method is used to determine what appointments\n     * will appear in bold on the calendar.\n     * \n     * @return An array of items that are in conflict with other items.\n     * @throws SQLException\n     */\n    public boolean[] getConflicts() {\n        boolean[] conflicts = new boolean[send.size()];\n        for (int i = 0; i < send.size(); i++) {\n            ApptBean ab = send.get(i);\n            long t = ab.getDate().getTime();\n            long m = types.getDurationByType(ab.getApptType()) * 60L * 1000L;\n            Timestamp time = new Timestamp(t + m);\n            for (int j = i + 1; j < send.size(); j++) {\n                if (send.get(j).getDate().before(time)) {\n                    conflicts[i] = true;\n                    conflicts[j] = true;\n                }\n            }\n        }\n        return conflicts;\n    }\n\n    /**\n     * Returns an array of booleans indicating whether there are conflicts between appointments in the given list.\n     * A conflict is considered to occur if the end time of one appointment overlaps with the start time of another appointment.\n     * \n     * @return an array of booleans where each element represents whether there is a conflict at the corresponding index in the 'send' list\n     */\n    \n    // Add more methods to manage appointments and conflicts\n    \n}\n/**\n * This class represents a utility for retrieving and organizing appointments for a specified month and year.\n * It contains a method that creates a hash table with all of the Appointments to be displayed on the calendar for the month and year being viewed.\n * \n * @author [Author Name]\n * @version 1.0\n */\npublic class AppointmentsUtility {\n\n    /**\n     * Retrieves a Hashtable containing appointments for a specified month and year.\n     * \n     * @param thisMonth the month for which to retrieve appointments\n     * @param thisYear the year for which to retrieve appointments\n     * @return a Hashtable<Integer, ArrayList<ApptBean>> containing appointments for the specified month and year\n     * @throws SQLException if there is an error retrieving the appointments\n     * \n     * This method retrieves appointments from a given action class and filters them based on the specified month and year. \n     * It then organizes the appointments into a Hashtable where the key is the day of the month and the value is a list of appointments for that day.\n     * If no appointments exist for a particular day, an empty list is created. \n     * The method returns the Hashtable containing the filtered appointments.\n     */\n    public Hashtable<Integer, ArrayList<ApptBean>> getApptsTable(int thisMonth, int thisYear) {\n        a_action.getMyAppointments();\n        Hashtable<Integer, ArrayList<ApptBean>> atable = new Hashtable<Integer, ArrayList<ApptBean>>();\n        Calendar a = Calendar.getInstance();\n        \n        for (ApptBean b : appts) {\n            a.setTimeInMillis(b.getDate().getTime());\n            if (a.get(Calendar.MONTH) == thisMonth && a.get(Calendar.YEAR) == thisYear) {\n                if (!atable.containsKey(a.get(Calendar.DAY_OF_MONTH)))\n                    atable.put(a.get(Calendar.DAY_OF_MONTH), new ArrayList<ApptBean>());\n                \n                ArrayList<ApptBean> l = atable.get(a.get(Calendar.DAY_OF_MONTH));\n                l.add(b);\n                send.add(b);\n                atable.put(a.get(Calendar.DAY_OF_MONTH), l);\n            }\n        }\n        \n        return atable;\n    }\n}\n**/\nSure! Here is a comprehensive JavaDoc comment for the class:\n\n/**\n * This class provides utility methods for managing office visits and lab procedures in a medical system.\n * It contains methods to retrieve and organize office visits and lab procedures based on the month and year being viewed.\n * The main functionalities of this class include creating hash tables to store office visits and lab procedures for a specific month and year,\n * and returning these organized data structures for display on a calendar.\n * \n * The class includes methods to retrieve office visits and lab procedures from a data source, filter them based on the specified month and year,\n * and store them in hash tables with day values as keys and lists of corresponding objects as values.\n * \n * Overall, this class facilitates the rendering of office visits and lab procedures on a calendar view, providing a convenient way to display\n * and manage medical appointments and procedures within the system.\n * \n * @author [Your Name]\n * @version 1.0\n * @since [Date]\n */\n \nPlease replace [Your Name] and [Date] with your actual information.\n/**\n * This class represents an action that generates a calendar view of lab procedures for a given month and year.\n * It contains a method that creates a hash table with all lab procedures to be displayed on the calendar.\n * The main functionalities of this class include retrieving lab procedures based on the month and year provided,\n * organizing them by day of the month, and returning a Hashtable mapping day of the month to a list of LabProcedureBeans.\n * \n * The class constructor initializes various actions and data structures needed for generating the calendar view.\n * \n * @param thisMonth The month of the calendar to be rendered\n * @param thisYear The year of the calendar to be rendered\n * @return A Hashtable containing the LabProcedureBeans to be rendered\n * @throws SQLException if there is an error in retrieving lab procedures\n */\npublic Hashtable<Integer, ArrayList<LabProcedureBean>> getLabProceduresTable(int thisMonth, int thisYear) {\n    Calendar a = Calendar.getInstance();\n    Hashtable<Integer, ArrayList<LabProcedureBean>> ptable = new Hashtable<>();\n    \n    for (LabProcedureBean b : procs) {\n        a.setTimeInMillis(b.getTimestamp().getTime());\n        if (a.get(Calendar.MONTH) == thisMonth && a.get(Calendar.YEAR) == thisYear) {\n            if (!ptable.containsKey(a.get(Calendar.DAY_OF_MONTH)))\n                ptable.put(a.get(Calendar.DAY_OF_MONTH), new ArrayList<LabProcedureBean>());\n            \n            ArrayList<LabProcedureBean> l = ptable.get(a.get(Calendar.DAY_OF_MONTH));\n            l.add(b);\n            ptable.put(a.get(Calendar.DAY_OF_MONTH), l);\n        }\n    }\n    \n    return ptable;\n}\n\n/**\n * Constructor for GenerateCalendarAction class.\n * Initializes actions and data structures needed for generating the calendar view.\n * \n * @param factory The DAOFactory used to create the DAOs used in this action\n * @param loggedInMID The MID of the user who is logged in\n */\npublic GenerateCalendarAction(DAOFactory factory, long loggedInMID) {\n    a_action = new ViewMyApptsAction(factory, loggedInMID);\n    types = new EditApptTypeAction(factory, loggedInMID);\n    r_action = new ViewMyRecordsAction(factory, loggedInMID);\n    send = new ArrayList<ApptBean>();\n}\n*/\n/**\n * The GenerateCalendarAction class represents an action that is responsible for generating a calendar view for the user. \n * It initializes three actions: ViewMyApptsAction, EditApptTypeAction, and ViewMyRecordsAction, using the provided DAOFactory and loggedInMID. \n * Additionally, it maintains an ArrayList of ApptBean objects to store appointments.\n * \n * This class allows the user to view their appointments, edit appointment types, and view their medical records. \n * It serves as a central hub for managing the user's calendar-related activities.\n * \n * The GenerateCalendarAction class encapsulates the logic for interacting with the database through the DAOFactory and managing the user's calendar events.\n * \n * @param factory the DAOFactory used to interact with the database\n * @param loggedInMID the ID of the currently logged in user\n */\npublic class GenerateCalendarAction {\n    private ViewMyApptsAction a_action;\n    private EditApptTypeAction types;\n    private ViewMyRecordsAction r_action;\n    private List<ApptBean> send;\n}\n*/"
    }
]