[
    {
        "methods": [
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"SELECT * FROM TransactionLog ORDER BY timeLogged DESC\");\r\n        ResultSet rs = ps.executeQuery();\r\n        return loader.loadList(rs);\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public List<TransactionBean> getAllTransactions()",
                "comments": "Optional[/**\r\n * Returns the whole transaction log\r\n *\r\n * @return\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Retrieves all transactions from the database in descending order based on the time they were logged.\n * \n * @return A list of TransactionBean objects representing all transactions in the database\n * @throws DBException if there is an error accessing the database\n */"
            },
            {
                "body": "Optional[{\r\n    logTransaction(type, loggedInMID, 0L, \"\");\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public void logTransaction(TransactionType, long)",
                "comments": "Optional[/**\r\n * Log a transaction, just giving it the person who is logged in and the type\r\n *\r\n * @param type The {@link TransactionType} enum representing the type this transaction is.\r\n * @param loggedInMID The MID of the user who is logged in.\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Logs a transaction with the specified type and transaction ID.\n * \n * @param type the type of the transaction to be logged\n * @param transactionID the ID of the transaction to be logged\n * \n * This method logs a transaction with the given type and transaction ID. It also logs the current user's ID and sets the transaction status to 0. Additionally, it can include an optional message for further details. \n * \n * @return void\n */"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"INSERT INTO TransactionLog(loggedInMID, secondaryMID, \" + \"transactionCode, addedInfo) VALUES(?,?,?,?)\");\r\n        ps.setLong(1, loggedInMID);\r\n        ps.setLong(2, secondaryMID);\r\n        ps.setInt(3, type.getCode());\r\n        ps.setString(4, addedInfo);\r\n        ps.executeUpdate();\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public void logTransaction(TransactionType, long, long, String)",
                "comments": "Optional[/**\r\n * Log a transaction, with all of the info. The meaning of secondaryMID and addedInfo changes depending on\r\n * the transaction type.\r\n *\r\n * @param type The {@link TransactionType} enum representing the type this transaction is.\r\n * @param loggedInMID The MID of the user who is logged in.\r\n * @param secondaryMID Typically, the MID of the user who is being acted upon.\r\n * @param addedInfo A note about a subtransaction, or specifics of this transaction (for posterity).\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Logs a transaction into the database.\n * \n * @param type The type of transaction (e.g. DEPOSIT, WITHDRAWAL, TRANSFER)\n * @param loggedInMID The ID of the logged-in member initiating the transaction\n * @param secondaryMID The ID of the secondary member involved in the transaction\n * @param addedInfo Additional information related to the transaction\n * \n * @throws DBException if an error occurs while accessing the database\n */\npublic void logTransaction(TransactionType type, long loggedInMID, long secondaryMID, String addedInfo) {\n    Connection conn = null;\n    PreparedStatement ps = null;\n    try {\n        conn = factory.getConnection();\n        ps = conn.prepareStatement(\"INSERT INTO TransactionLog(loggedInMID, secondaryMID, \" + \"transactionCode, addedInfo) VALUES(?,?,?,?)\");\n        ps.setLong(1, loggedInMID);\n        ps.setLong(2, secondaryMID);\n        ps.setInt(3, type.getCode());\n        ps.setString(4, addedInfo);\n        ps.executeUpdate();\n    } catch (SQLException e) {\n        e.printStackTrace();\n        throw new DBException(e);\n    } finally {\n        DBUtil.closeConnection(conn, ps);\n    }\n}\n*/"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"SELECT * FROM TransactionLog WHERE secondaryMID=? AND transactionCode \" + \"IN(\" + TransactionType.patientViewableStr + \") ORDER BY timeLogged DESC\");\r\n        ps.setLong(1, patientID);\r\n        ResultSet rs = ps.executeQuery();\r\n        List<TransactionBean> tbList = loader.loadList(rs);\r\n        tbList = addAndSortRoles(tbList, patientID, getByRole);\r\n        return tbList;\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public List<TransactionBean> getAllRecordAccesses(long, boolean)",
                "comments": "Optional[/**\r\n * Return a list of all transactions in which an HCP accessed the given patient's record\r\n *\r\n * @param patientID The MID of the patient in question.\r\n * @return A java.util.List of transactions.\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Retrieves all record accesses for a given patient ID.\n * \n * @param patientID the ID of the patient whose record accesses are being retrieved\n * @param getByRole flag indicating whether to include record accesses based on roles\n * @return a list of TransactionBean objects representing the record accesses, sorted by time logged\n * @throws DBException if there is an error accessing the database\n */"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        if (loggedInRole.compareTo(\"any\") == 0) {\r\n            loggedInRole = \"*\";\r\n        }\r\n        if (secondaryRole.compareTo(\"any\") == 0) {\r\n            secondaryRole = \"*\";\r\n        }\r\n        ps = conn.prepareStatement(\"SELECT * FROM TransactionLog, Users  WHERE (MID=loggedInMID OR MID=secondaryMID) AND (Role=? OR Role=?) \" + \" AND transactionCode=? AND timeLogged >= ? AND timeLogged <= ?\" + \" ORDER BY timeLogged DESC\");\r\n        ps.setString(1, loggedInRole);\r\n        ps.setString(2, secondaryRole);\r\n        ps.setInt(3, type.getCode());\r\n        ps.setDate(4, begin);\r\n        ps.setDate(5, end);\r\n        ResultSet rs = ps.executeQuery();\r\n        List<TransactionBean> tbList = loader.loadList(rs);\r\n        //tbList = addAndSortRoles(tbList, patientID, getByRole);\r\n        return tbList;\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "public List<TransactionBean> getTransactionsFor(String, String, Date, Date, TransactionType)",
                "comments": "Optional[/**\r\n * The Most Thorough Fetch\r\n * @param loggedInRole Role of loggedIn\r\n * @param secondaryRole Role of secondary\r\n * @param begin Beginning of date range\r\n * @param end End of date range\r\n * @param type Type of transaction\r\n * @return\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": "Optional[[//tbList = addAndSortRoles(tbList, patientID, getByRole);\r\n]]",
                "generated_comment": "/**\n * Retrieves a list of TransactionBeans based on the specified criteria.\n * Transactions are filtered by the logged-in role, secondary role, transaction type,\n * and time range. The results are ordered by the time they were logged in descending order.\n * \n * @param loggedInRole the role of the logged-in user\n * @param secondaryRole the secondary role to filter transactions by\n * @param begin the start date of the time range\n * @param end the end date of the time range\n * @param type the TransactionType to filter by\n * @return a List of TransactionBeans that meet the specified criteria\n * @throws DBException if there is an issue with the database connection or query execution\n */"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"SELECT * FROM TransactionLog WHERE secondaryMID=? AND transactionCode IN (\" + TransactionType.patientViewableStr + \") \" + \"AND timeLogged >= ? AND timeLogged <= ? ORDER BY timeLogged DESC\");\r\n        ps.setLong(1, patientID);\r\n        ps.setTimestamp(2, new Timestamp(lower.getTime()));\r\n        // add 1 day's worth to include the upper\r\n        ps.setTimestamp(3, new Timestamp(upper.getTime() + 1000L * 60L * 60 * 24L));\r\n        ResultSet rs = ps.executeQuery();\r\n        List<TransactionBean> tbList = loader.loadList(rs);\r\n        tbList = addAndSortRoles(tbList, patientID, getByRole);\r\n        return tbList;\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "public List<TransactionBean> getRecordAccesses(long, java.util.Date, java.util.Date, boolean)",
                "comments": "Optional[/**\r\n * Return a list of all transactions in which an HCP accessed the given patient's record, within the dates\r\n *\r\n * @param patientID The MID of the patient in question.\r\n * @param lower The starting date as a java.util.Date\r\n * @param upper The ending date as a java.util.Date\r\n * @return A java.util.List of transactions.\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": "Optional[[// add 1 day's worth to include the upper\r\n]]",
                "generated_comment": "/**\n * Retrieves a list of transaction records for a given patient ID within a specified time range.\n * Only transactions with codes that are viewable by patients are included in the result.\n * The records are sorted by the time they were logged in descending order.\n * \n * @param patientID the ID of the patient for whom the transaction records are retrieved\n * @param lower the lower bound of the time range for the transaction records\n * @param upper the upper bound of the time range for the transaction records\n * @param getByRole flag indicating whether to include roles in the result\n * @return a list of TransactionBean objects representing the transaction records\n * @throws DBException if there is an error accessing the database\n */"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"SELECT TransactionCode, count(transactionID) as TotalCount, \" + \"count(if(loggedInMID<9000000000, transactionID, null)) as PatientCount, \" + \"count(if(loggedInMID>=9000000000, transactionID, null)) as PersonnelCount \" + \"FROM TransactionLog GROUP BY transactionCode ORDER BY transactionCode ASC\");\r\n        ResultSet rs = ps.executeQuery();\r\n        return operationalProfileLoader.loadSingle(rs);\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public OperationalProfile getOperationalProfile()",
                "comments": "Optional[/**\r\n * Returns the operation profile\r\n *\r\n * @return The OperationalProfile as a bean.\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Retrieves the operational profile data from the database.\n * This method executes a SQL query to retrieve the total count of transactions, \n * the count of transactions made by patients, and the count of transactions made by personnel \n * for each transaction code. The results are then loaded into an OperationalProfile object.\n * \n * @return An OperationalProfile object containing the operational profile data.\n * @throws DBException if there is an error accessing the database\n */"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        for (TransactionBean t : tbList) {\r\n            ps = conn.prepareStatement(\"SELECT Role FROM Users WHERE MID=?\");\r\n            ps.setLong(1, t.getLoggedInMID());\r\n            ResultSet rs = ps.executeQuery();\r\n            String role = \"\";\r\n            if (rs.next())\r\n                role = rs.getString(\"Role\");\r\n            if (role.equals(\"er\"))\r\n                role = \"Emergency Responder\";\r\n            else if (role.equals(\"uap\"))\r\n                role = \"UAP\";\r\n            else if (role.equals(\"hcp\")) {\r\n                role = \"LHCP\";\r\n                ps = conn.prepareStatement(\"SELECT PatientID FROM DeclaredHCP WHERE HCPID=?\");\r\n                ps.setLong(1, t.getLoggedInMID());\r\n                ResultSet rs2 = ps.executeQuery();\r\n                while (rs2.next()) {\r\n                    if (rs2.getLong(\"PatientID\") == patientID) {\r\n                        role = \"DLHCP\";\r\n                        break;\r\n                    }\r\n                }\r\n            } else if (role.equals(\"patient\")) {\r\n                role = \"Patient\";\r\n                ps = conn.prepareStatement(\"SELECT representeeMID FROM Representatives WHERE representerMID=?\");\r\n                ps.setLong(1, t.getLoggedInMID());\r\n                ResultSet rs2 = ps.executeQuery();\r\n                while (rs2.next()) {\r\n                    if (rs2.getLong(\"representeeMID\") == patientID) {\r\n                        role = \"Personal Health Representative\";\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            t.setRole(role);\r\n        }\r\n        if (sortByRole) {\r\n            TransactionBean[] array = new TransactionBean[tbList.size()];\r\n            array[0] = tbList.get(0);\r\n            TransactionBean t;\r\n            for (int i = 1; i < tbList.size(); i++) {\r\n                t = tbList.get(i);\r\n                String role = t.getRole();\r\n                int j = 0;\r\n                while (array[j] != null && role.compareToIgnoreCase(array[j].getRole()) >= 0) j++;\r\n                for (int k = i; k > j; k--) {\r\n                    array[k] = array[k - 1];\r\n                }\r\n                array[j] = t;\r\n            }\r\n            int size = tbList.size();\r\n            for (int i = 0; i < size; i++) tbList.set(i, array[i]);\r\n        }\r\n        return tbList;\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "private List<TransactionBean> addAndSortRoles(List<TransactionBean>, long, boolean)",
                "comments": "Optional[/**\r\n * @param tbList\r\n * @param patientID\r\n * @param sortByRole\r\n * @return\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * This method adds roles to a list of TransactionBeans based on the logged-in user's role in the database and sorts the list by role if specified.\n * \n * @param tbList The list of TransactionBeans to add roles to and potentially sort\n * @param patientID The ID of the patient associated with the logged-in user\n * @param sortByRole A boolean flag indicating whether to sort the list by role\n * @return A List of TransactionBeans with roles added and potentially sorted by role\n * @throws DBException if there is an error accessing the database\n */"
            }
        ],
        "constructors": [
            {
                "body": "{\r\n    this.factory = factory;\r\n}",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public TransactionDAO(DAOFactory)",
                "comments": "Optional[/**\r\n * The typical constructor.\r\n * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Constructs a new TransactionDAO with the specified DAOFactory.\n * \n * @param factory the DAOFactory to be used for creating DAO objects\n * @throws IllegalArgumentException if the factory is null\n */\npublic TransactionDAO(DAOFactory factory) {\n    if (factory == null) {\n        throw new IllegalArgumentException(\"Factory cannot be null\");\n    }\n    this.factory = factory;\n}\n*/"
            }
        ],
        "signature": "TransactionDAO",
        "variables": [
            "private DAOFactory factory",
            "private TransactionBeanLoader loader",
            "private OperationalProfileLoader operationalProfileLoader"
        ],
        "generated_class_comment": "/**\n * This class represents a data access object for managing transaction logs in a database.\n * It provides methods for retrieving all transactions and logging new transactions.\n * \n * The main functionalities of this class include:\n * - Retrieving all transactions from the database in descending order based on the time they were logged\n * - Logging a new transaction with the specified type, user ID, and optional message\n * \n * The overall behavior of this class is to interact with the database to retrieve and log transactions.\n * \n * @author [Author Name]\n * @version 1.0\n */\n/**\n * This class represents a utility for logging transactions into the database. It provides a method to log a transaction with all the necessary information such as transaction type, logged-in member ID, secondary member ID, and additional information. The class handles database connections and prepares statements to insert transaction logs into the database table.\n * \n * The main functionalities of this class include:\n * - Logging transactions with detailed information\n * - Handling database connections and statements for inserting transaction logs\n * \n * The behavior of this class is to log transactions into the database based on the provided transaction type, logged-in member ID, secondary member ID, and additional information. It catches and handles any SQLException that may occur during the database operation and throws a DBException in case of an error.\n * \n * @throws DBException if an error occurs while accessing the database\n */\npublic void logTransaction(TransactionType type, long loggedInMID, long secondaryMID, String addedInfo) {\n    // Method implementation goes here\n}\n */\npublic class TransactionDAO {\n\n    /**\n     * Inserts a new transaction log entry into the database.\n     * \n     * @param loggedInMID The MID of the user who performed the transaction.\n     * @param secondaryMID The MID of the secondary user involved in the transaction.\n     * @param type The type of transaction being logged.\n     * @param addedInfo Additional information about the transaction.\n     * @throws DBException if there is an error accessing the database\n     */\n    public void insertTransactionLog(long loggedInMID, long secondaryMID, TransactionType type, String addedInfo) {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        try {\n            conn = factory.getConnection();\n            ps = conn.prepareStatement(\"INSERT INTO TransactionLog(loggedInMID, secondaryMID, transactionCode, addedInfo) VALUES(?,?,?,?)\");\n            ps.setLong(1, loggedInMID);\n            ps.setLong(2, secondaryMID);\n            ps.setInt(3, type.getCode());\n            ps.setString(4, addedInfo);\n            ps.executeUpdate();\n        } catch (SQLException e) {\n            e.printStackTrace();\n            throw new DBException(e);\n        } finally {\n            DBUtil.closeConnection(conn, ps);\n        }\n    }\n\n    /**\n     * Retrieves all record accesses for a given patient ID.\n     * \n     * @param patientID the ID of the patient whose record accesses are being retrieved\n     * @param getByRole flag indicating whether to include record accesses based on roles\n     * @return a list of TransactionBean objects representing the record accesses, sorted by time logged\n     * @throws DBException if there is an error accessing the database\n     */\n    public List<TransactionBean> getAllRecordAccesses(long patientID, boolean getByRole) {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        try {\n            conn = factory.getConnection();\n            ps = conn.prepareStatement(\"SELECT * FROM TransactionLog WHERE secondaryMID=? AND transactionCode IN(\" + TransactionType.patientViewableStr + \") ORDER BY timeLogged DESC\");\n            ps.setLong(1, patientID);\n            ResultSet rs = ps.executeQuery();\n            List<TransactionBean> tbList = loader.loadList(rs);\n            tbList = addAndSortRoles(tbList, patientID, getByRole);\n            return tbList;\n        } catch (SQLException e) {\n            e.printStackTrace();\n            throw new DBException(e);\n        } finally {\n            DBUtil.closeConnection(conn, ps);\n        }\n    }\n}]\", \"hasComment\": true, \"hasInnerComment\": false, \"signature\": \"public List<TransactionBean> getAllRecordAccesses(long, boolean)\", \"comments\": \"Optional[/**\\r\\n * Return a list of all transactions in which an HCP accessed the given patient's record\\r\\n *\\r\\n * @param patientID The MID of the patient in question.\\r\\n * @return A java.util.List of transactions.\\r\\n * @throws DBException\\r\\n */\\r\\n]\", \"innerComments\": null\n/**\n * Retrieves a list of TransactionBeans based on the specified criteria.\n * Transactions are filtered by the logged-in role, secondary role, transaction type,\n * and time range. The results are ordered by the time they were logged in descending order.\n * \n * @param loggedInRole the role of the logged-in user\n * @param secondaryRole the secondary role to filter transactions by\n * @param begin the start date of the time range\n * @param end the end date of the time range\n * @param type the type of transaction\n * @return a list of TransactionBeans that meet the specified criteria\n * @throws DBException if there is an issue with the database connection\n */\npublic List<TransactionBean> getTransactionsFor(String loggedInRole, String secondaryRole, Date begin, Date end, TransactionType type) {\n    Connection conn = null;\n    PreparedStatement ps = null;\n    try {\n        conn = factory.getConnection();\n        if (loggedInRole.compareTo(\"any\") == 0) {\n            loggedInRole = \"*\";\n        }\n        if (secondaryRole.compareTo(\"any\") == 0) {\n            secondaryRole = \"*\";\n        }\n        ps = conn.prepareStatement(\"SELECT * FROM TransactionLog, Users WHERE (MID=loggedInMID OR MID=secondaryMID) AND (Role=? OR Role=?) \" + \" AND transactionCode=? AND timeLogged >= ? AND timeLogged <= ?\" + \" ORDER BY timeLogged DESC\");\n        ps.setString(1, loggedInRole);\n        ps.setString(2, secondaryRole);\n        ps.setInt(3, type.getCode());\n        ps.setDate(4, begin);\n        ps.setDate(5, end);\n        ResultSet rs = ps.executeQuery();\n        List<TransactionBean> tbList = loader.loadList(rs);\n        //tbList = addAndSortRoles(tbList, patientID, getByRole);\n        return tbList;\n    } catch (SQLException e) {\n        e.printStackTrace();\n        throw new DBException(e);\n    } finally {\n        DBUtil.closeConnection(conn, ps);\n    }\n}\n*/\n/**\n * Retrieves a list of transaction records for a given patient ID within a specified time range.\n * Only transactions with codes that are viewable by patients are included.\n * \n * This method returns a list of all transactions in which an HCP accessed the given patient's record, within the specified dates.\n * \n * @param patientID The MID of the patient in question.\n * @param lower The starting date as a java.util.Date.\n * @param upper The ending date as a java.util.Date.\n * @param getByRole Boolean flag to indicate if roles should be included in the result.\n * @return A java.util.List of TransactionBeans that meet the specified criteria.\n * @throws DBException if there is an issue with the database connection or query execution.\n */\npublic List<TransactionBean> getRecordAccesses(long patientID, java.util.Date lower, java.util.Date upper, boolean getByRole) {\n    Connection conn = null;\n    PreparedStatement ps = null;\n    try {\n        conn = factory.getConnection();\n        ps = conn.prepareStatement(\"SELECT * FROM TransactionLog WHERE secondaryMID=? AND transactionCode IN (\" + TransactionType.patientViewableStr + \") \" + \"AND timeLogged >= ? AND timeLogged <= ? ORDER BY timeLogged DESC\");\n        ps.setLong(1, patientID);\n        ps.setTimestamp(2, new Timestamp(lower.getTime()));\n        // add 1 day's worth to include the upper\n        ps.setTimestamp(3, new Timestamp(upper.getTime() + 1000L * 60L * 60 * 24L));\n        ResultSet rs = ps.executeQuery();\n        List<TransactionBean> tbList = loader.loadList(rs);\n        tbList = addAndSortRoles(tbList, patientID, getByRole);\n        return tbList;\n    } catch (SQLException e) {\n        e.printStackTrace();\n        throw new DBException(e);\n    } finally {\n        DBUtil.closeConnection(conn, ps);\n    }\n}\n*/\n/**\n * Retrieves the operational profile data from the database.\n * This method executes a SQL query to retrieve the total count of transactions, \n * the count of transactions made by patients, and the count of transactions made by personnel \n * for each transaction code. The results are then loaded into an OperationalProfile object.\n * \n * @return An OperationalProfile object representing the operation profile data.\n * @throws DBException if there is an error accessing the database\n */\npublic OperationalProfile getOperationalProfile() {\n    Connection conn = null;\n    PreparedStatement ps = null;\n    try {\n        conn = factory.getConnection();\n        ps = conn.prepareStatement(\"SELECT TransactionCode, count(transactionID) as TotalCount, \" + \n                                   \"count(if(loggedInMID<9000000000, transactionID, null)) as PatientCount, \" + \n                                   \"count(if(loggedInMID>=9000000000, transactionID, null)) as PersonnelCount \" + \n                                   \"FROM TransactionLog GROUP BY transactionCode ORDER BY transactionCode ASC\");\n        ResultSet rs = ps.executeQuery();\n        return operationalProfileLoader.loadSingle(rs);\n    } catch (SQLException e) {\n        e.printStackTrace();\n        throw new DBException(e);\n    } finally {\n        DBUtil.closeConnection(conn, ps);\n    }\n}\n*/\n/**\n * This class contains the operational profile data and provides methods to retrieve and manipulate the data.\n * It handles database operations to fetch user roles based on their IDs and sets the appropriate role for each user.\n * The class also allows sorting the transaction beans based on user roles if required.\n * \n * @throws DBException if there is an error accessing the database\n */\n*/\n/**\n * The TransactionDAO class represents a Data Access Object (DAO) for handling transactions in the database.\n * It provides methods for adding and sorting roles in a list of TransactionBeans based on the logged-in user's role,\n * as well as for accessing and manipulating transaction data in the database.\n * \n * This class contains a constructor that initializes the DAOFactory associated with this DAO, which is used for obtaining SQL connections.\n * \n * The main functionalities of this class include:\n * - Adding and sorting roles in a list of TransactionBeans\n * - Accessing and manipulating transaction data in the database\n * \n * The behavior of this class is to interact with the database to perform CRUD (Create, Read, Update, Delete) operations on transaction data.\n * It ensures that the data is properly handled and that any errors encountered during database operations are appropriately handled and reported.\n * \n * This class relies on the DAOFactory for obtaining database connections and other resources necessary for database operations.\n * \n * @author [Author Name]\n * @version 1.0\n * @see DAOFactory\n */\n*/"
    }
]