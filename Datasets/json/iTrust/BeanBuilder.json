[
    {
        "methods": [
            {
                "body": "Optional[{\r\n    // JavaBeans should not have overloaded methods, according to their API\r\n    // (a stupid limitation!)\r\n    // Nevertheless, we should check for it\r\n    checkOverloadedMethods(bean);\r\n    // Use an introspector to find all of the getXXX or setXXX, we only want\r\n    // the setXXX\r\n    PropertyDescriptor[] propertyDescriptors = Introspector.getBeanInfo(bean.getClass()).getPropertyDescriptors();\r\n    for (PropertyDescriptor descriptor : propertyDescriptors) {\r\n        // if object is null, either it was ignored or empty - just go with\r\n        // bean's default\r\n        String[] value = (String[]) map.get(descriptor.getName());\r\n        Method writeMethod = descriptor.getWriteMethod();\r\n        if (!\"class\".equals(descriptor.getName()) && value != null && writeMethod != null) {\r\n            // descriptor's name is the name of your property; like\r\n            // firstName\r\n            // only take the first string\r\n            try {\r\n                // Skip the setters for enumerations\r\n                if (writeMethod.getParameterTypes()[0].getEnumConstants() == null)\r\n                    writeMethod.invoke(bean, new Object[] { value[0] });\r\n            } catch (IllegalArgumentException e) {\r\n                // Throw a more informative exception\r\n                throw new IllegalArgumentException(e.getMessage() + \" with \" + writeMethod.getName() + \" and \" + value[0]);\r\n            }\r\n        }\r\n    }\r\n    return bean;\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "public T build(Map, T)",
                "comments": "Optional[// this warning is only suppressed because Map isn't parameterized (old JSP)\r\n]",
                "innerComments": "Optional[[// JavaBeans should not have overloaded methods, according to their API\r\n, // (a stupid limitation!)\r\n, // Use an introspector to find all of the getXXX or setXXX, we only want\r\n, // Nevertheless, we should check for it\r\n, // the setXXX\r\n, // if object is null, either it was ignored or empty - just go with\r\n, // bean's default\r\n, // descriptor's name is the name of your property; like\r\n, // firstName\r\n, // only take the first string\r\n, // Skip the setters for enumerations\r\n, // Throw a more informative exception\r\n]]",
                "generated_comment": "/**\n * Builds a JavaBean object by populating its properties with values from a given map.\n * \n * @param map a map containing property names as keys and corresponding values as strings\n * @param bean the JavaBean object to populate with values from the map\n * @return the JavaBean object with its properties populated with values from the map\n * @throws IllegalArgumentException if an error occurs while setting a property value\n */\npublic T build(Map<String, String> map, T bean) {\n    // JavaBeans should not have overloaded methods, according to their API\n    // (a stupid limitation!)\n    // Nevertheless, we should check for it\n    checkOverloadedMethods(bean);\n    \n    // Use an introspector to find all of the getXXX or setXXX, we only want\n    // the setXXX\n    PropertyDescriptor[] propertyDescriptors = Introspector.getBeanInfo(bean.getClass()).getPropertyDescriptors();\n    for (PropertyDescriptor descriptor : propertyDescriptors) {\n        // if object is null, either it was ignored or empty - just go with\n        // bean's default\n        String[] value = map.get(descriptor.getName());\n        Method writeMethod = descriptor.getWriteMethod();\n        if (!\"class\".equals(descriptor.getName()) && value != null && writeMethod != null) {\n            // descriptor's name is the name of your property; like\n            // firstName\n            // only take the first string\n            try {\n                // Skip the setters for enumerations\n                if (writeMethod.getParameterTypes()[0].getEnumConstants() == null)\n                    writeMethod.invoke(bean, new Object[] { value[0] });\n            } catch (IllegalArgumentException e) {\n                // Throw a more informative exception\n                throw new IllegalArgumentException(e.getMessage() + \" with \" + writeMethod.getName() + \" and \" + value[0]);\n            }\n        }\n    }\n    return bean;\n}\n*/"
            },
            {
                "body": "Optional[{\r\n    Method[] methods = bean.getClass().getDeclaredMethods();\r\n    HashMap<String, String> nameMap = new HashMap<String, String>(methods.length);\r\n    for (Method method : methods) {\r\n        if (nameMap.get(method.getName()) != null)\r\n            throw new IllegalArgumentException(bean.getClass().getName() + \" should not have any overloaded methods, like \" + method.getName());\r\n        if (// allow an equals override\r\n        !\"equals\".equals(method.getName()))\r\n            nameMap.put(method.getName(), \"exists\");\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "private void checkOverloadedMethods(T)",
                "comments": "Optional[/**\r\n * Checks for overloaded methods\r\n *\r\n * @param bean item to check\r\n */\r\n]",
                "innerComments": "Optional[[// allow an equals override\r\n]]",
                "generated_comment": "/**\n * Checks if the given bean class has any overloaded methods, except for the equals method.\n * \n * @param bean the bean object to check for overloaded methods\n * \n * @throws IllegalArgumentException if the bean class has any overloaded methods, except for the equals method\n */\nprivate void checkOverloadedMethods(T bean) {\n    Method[] methods = bean.getClass().getDeclaredMethods();\n    HashMap<String, String> nameMap = new HashMap<String, String>(methods.length);\n    \n    for (Method method : methods) {\n        if (nameMap.get(method.getName()) != null)\n            throw new IllegalArgumentException(bean.getClass().getName() + \" should not have any overloaded methods, like \" + method.getName());\n        \n        if (!\"equals\".equals(method.getName()))\n            nameMap.put(method.getName(), \"exists\");\n    }\n}\n```"
            }
        ],
        "constructors": [],
        "signature": "BeanBuilder",
        "variables": [],
        "generated_class_comment": "/**\n * The BeanBuilder class is responsible for building JavaBean objects by populating their properties with values from a given map.\n * It provides methods to check for overloaded methods in the JavaBean class and to populate the properties with values from the map.\n * \n * The main functionalities of this class include:\n * - Building a JavaBean object by populating its properties with values from a map\n * - Checking for overloaded methods in the JavaBean class\n * \n * The build method takes a map containing property names as keys and corresponding values as strings, along with the JavaBean object to populate.\n * It iterates through the property descriptors of the JavaBean class, sets the property values from the map, and returns the populated JavaBean object.\n * If an error occurs while setting a property value, an IllegalArgumentException is thrown.\n * \n * The checkOverloadedMethods method checks if the given JavaBean class has any overloaded methods, except for the equals method.\n * It throws an IllegalArgumentException if the JavaBean class has any overloaded methods, except for the equals method.\n * \n * Overall, the BeanBuilder class facilitates the easy population of JavaBean objects with values from a map and ensures that the JavaBean class does not have any overloaded methods.\n */\npublic class BeanBuilder {\n    // methods and constructors implementation\n}\n*/"
    }
]