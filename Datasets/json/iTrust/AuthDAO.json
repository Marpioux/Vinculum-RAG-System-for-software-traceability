[
    {
        "methods": [
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        pstmt = conn.prepareStatement(\"INSERT INTO Users (MID, PASSWORD, ROLE, sQuestion, sAnswer) VALUES (?,?,?,?,?)\");\r\n        pstmt.setLong(1, mid);\r\n        pstmt.setString(2, password);\r\n        pstmt.setString(3, role.toString());\r\n        pstmt.setString(4, \"Enter the random password given in your account email\");\r\n        String pwd = RandomPassword.getRandomPassword();\r\n        pstmt.setString(5, pwd);\r\n        pstmt.executeUpdate();\r\n        return pwd;\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, pstmt);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public String addUser(Long, Role, String)",
                "comments": "Optional[/**\r\n * Add a particular user to the system. Does not add user-specific information (e.g. Patient or HCP).\r\n * Initially sets security question to a random set of characters, so that nobody should be able to guess\r\n * its value.\r\n *\r\n * @param mid The user's MID as a Long.\r\n * @param role The role of the user as a Role enum {@link Role}\r\n * @param password The password for the new user.\r\n * @return A string representing the newly added randomly-generated password.\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Adds a new user to the database with the specified MID, role, and password.\n * Generates a random password for the user's security question and answer.\n * \n * @param mid the unique MID (Member ID) of the user\n * @param role the role of the user (e.g., ADMIN, USER)\n * @param password the password for the user\n * @return the randomly generated password for the user's security question and answer\n * @throws DBException if there is an error accessing the database\n */"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        pstmt = conn.prepareStatement(\"UPDATE Users SET sQuestion = ?, sAnswer = ? WHERE MID = ?\");\r\n        pstmt.setString(1, question);\r\n        pstmt.setString(2, answer);\r\n        pstmt.setLong(3, mid);\r\n        pstmt.executeUpdate();\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, pstmt);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public void setSecurityQuestionAnswer(String, String, long)",
                "comments": "Optional[/**\r\n * Reset the security question and answer for a particular user\r\n *\r\n * @param question The security question as a string.\r\n * @param answer The security answer as a string.\r\n * @param mid The MID of the user as a long.\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Sets the security question and answer for a user with the given member ID.\n * \n * @param question the security question to set\n * @param answer the security answer to set\n * @param mid the member ID of the user\n * \n * @throws DBException if there is an error updating the database\n */\npublic void setSecurityQuestionAnswer(String question, String answer, long mid) {\n    Connection conn = null;\n    PreparedStatement pstmt = null;\n    try {\n        conn = factory.getConnection();\n        pstmt = conn.prepareStatement(\"UPDATE Users SET sQuestion = ?, sAnswer = ? WHERE MID = ?\");\n        pstmt.setString(1, question);\n        pstmt.setString(2, answer);\n        pstmt.setLong(3, mid);\n        pstmt.executeUpdate();\n    } catch (SQLException e) {\n        e.printStackTrace();\n        throw new DBException(e);\n    } finally {\n        DBUtil.closeConnection(conn, pstmt);\n    }\n}\n*/"
            },
            {
                "body": "Optional[{\r\n    Role role = getUserRole(mid);\r\n    switch(role) {\r\n        case HCP:\r\n        case PHA:\r\n        case ADMIN:\r\n        case UAP:\r\n        case ER:\r\n            return factory.getPersonnelDAO().getName(mid);\r\n        case PATIENT:\r\n            return factory.getPatientDAO().getName(mid);\r\n        case TESTER:\r\n            return String.valueOf(mid);\r\n        default:\r\n            throw new iTrustException(\"Role \" + role + \" not supported\");\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public String getUserName(long)",
                "comments": "Optional[/**\r\n * Returns the user name of a user from just the MID\r\n *\r\n * @param mid The MID of the user to get the name of.\r\n * @return The user's name as a String.\r\n * @throws DBException\r\n * @throws iTrustException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Retrieves the username associated with the given user ID.\n * \n * @param mid the user ID of the user whose username is to be retrieved\n * @return the username of the user with the given user ID\n * @throws iTrustException if the role associated with the user ID is not supported\n */\npublic String getUserName(long mid) {\n    Role role = getUserRole(mid);\n    switch(role) {\n        case HCP:\n        case PHA:\n        case ADMIN:\n        case UAP:\n        case ER:\n            return factory.getPersonnelDAO().getName(mid);\n        case PATIENT:\n            return factory.getPatientDAO().getName(mid);\n        case TESTER:\n            return String.valueOf(mid);\n        default:\n            throw new iTrustException(\"Role \" + role + \" not supported\");\n    }\n}\n*/"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement pstmt = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        pstmt = conn.prepareStatement(\"SELECT role FROM Users WHERE MID=?\");\r\n        pstmt.setLong(1, mid);\r\n        ResultSet rs;\r\n        rs = pstmt.executeQuery();\r\n        if (rs.next()) {\r\n            return Role.parse(rs.getString(\"role\"));\r\n        } else {\r\n            throw new iTrustException(\"User does not exist\");\r\n        }\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, pstmt);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public Role getUserRole(long)",
                "comments": "Optional[/**\r\n * Returns the role of a particular MID\r\n *\r\n * @param mid The MID of the user to look up.\r\n * @return The {@link Role} of the user as an enum.\r\n * @throws DBException\r\n * @throws iTrustException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Retrieves the role of a user with the given MID from the database.\n * \n * @param mid the MID of the user whose role is to be retrieved\n * @return the role of the user with the given MID\n * @throws iTrustException if the user does not exist in the database\n * @throws DBException if there is an issue with the database connection or query\n */\npublic Role getUserRole(long mid) {\n    Connection conn = null;\n    PreparedStatement pstmt = null;\n    try {\n        conn = factory.getConnection();\n        pstmt = conn.prepareStatement(\"SELECT role FROM Users WHERE MID=?\");\n        pstmt.setLong(1, mid);\n        ResultSet rs;\n        rs = pstmt.executeQuery();\n        if (rs.next()) {\n            return Role.parse(rs.getString(\"role\"));\n        } else {\n            throw new iTrustException(\"User does not exist\");\n        }\n    } catch (SQLException e) {\n        e.printStackTrace();\n        throw new DBException(e);\n    } finally {\n        DBUtil.closeConnection(conn, pstmt);\n    }\n}\n*/"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"UPDATE Users SET password=? WHERE MID=?\");\r\n        ps.setString(1, password);\r\n        ps.setLong(2, mid);\r\n        ps.executeUpdate();\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public void resetPassword(long, String)",
                "comments": "Optional[/**\r\n * Change the password of a particular user\r\n *\r\n * @param mid The MID of the user whose password we are changing.\r\n * @param password The new password.\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Resets the password for a user with the given MID.\n * \n * @param mid the unique identifier of the user\n * @param password the new password to set for the user\n * \n * @throws DBException if there is an error accessing the database\n */\npublic void resetPassword(long mid, String password) {\n    Connection conn = null;\n    PreparedStatement ps = null;\n    try {\n        conn = factory.getConnection();\n        ps = conn.prepareStatement(\"UPDATE Users SET password=? WHERE MID=?\");\n        ps.setString(1, password);\n        ps.setLong(2, mid);\n        ps.executeUpdate();\n    } catch (SQLException e) {\n        e.printStackTrace();\n        throw new DBException(e);\n    } finally {\n        DBUtil.closeConnection(conn, ps);\n    }\n}\n```"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"SELECT sQuestion FROM Users WHERE MID=?\");\r\n        ps.setLong(1, mid);\r\n        ResultSet r = ps.executeQuery();\r\n        if (r.next())\r\n            return r.getString(\"sQuestion\");\r\n        else\r\n            throw new iTrustException(\"No security question set for MID: \" + mid);\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public String getSecurityQuestion(long)",
                "comments": "Optional[/**\r\n * Return the security question for a particular user.\r\n *\r\n * @param mid The MID of the user we are looking up.\r\n * @return The security question of the user we are looking up.\r\n * @throws iTrustException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Retrieves the security question associated with the given user's MID.\n * \n * @param mid the user's MID for which to retrieve the security question\n * @return the security question for the user with the specified MID\n * @throws iTrustException if no security question is set for the specified MID\n * @throws DBException if there is an issue with the database connection or query execution\n */"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"SELECT sAnswer FROM Users WHERE MID=?\");\r\n        ps.setLong(1, mid);\r\n        ResultSet r = ps.executeQuery();\r\n        if (r.next())\r\n            return r.getString(\"sAnswer\");\r\n        else\r\n            throw new iTrustException(\"No security answer set for MID \" + mid);\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public String getSecurityAnswer(long)",
                "comments": "Optional[/**\r\n * Return the security answer of a particular user\r\n *\r\n * @param mid The MID of the user we are looking up.\r\n * @return The security answer as a String.\r\n * @throws iTrustException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Retrieves the security answer associated with a given MID (Medical Record Number).\n * \n * @param mid the Medical Record Number of the user whose security answer is to be retrieved\n * @return the security answer associated with the given MID\n * @throws iTrustException if no security answer is set for the provided MID\n * @throws DBException if there is a problem with the database connection or query execution\n */"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"UPDATE LoginFailures SET FailureCount=FailureCount+1, lastFailure=CURRENT_TIMESTAMP WHERE IPAddress=?\");\r\n        //.prepareStatement(\"INSERT INTO LoginFailures VALUES(?,?,?)\");\r\n        ps.setString(1, ipAddr);\r\n        //ps.setInt(2, failures);\r\n        //ps.setDate(3, Calendar.getInstance().getTime());\r\n        int numUpdated = ps.executeUpdate();\r\n        if (// if there wasn't an empty row to begin with\r\n        numUpdated == 0)\r\n            // now they have a row AND a strike against\r\n            insertLoginFailureRow(ipAddr, 1, conn);\r\n        // 'em\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "public void recordLoginFailure(String)",
                "comments": "Optional[/**\r\n * Record a login failure, which blacklists the ipAddress. Uses the database table like a hash table where\r\n * the key is the user's IP address. If the user's IP address is not in the table, a row with \"1\" is\r\n * added.\r\n *\r\n * @param ipAddr The IP address of the user as a String.\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": "Optional[[//ps.setInt(2, failures);\r\n, // 'em\r\n, //.prepareStatement(\"INSERT INTO LoginFailures VALUES(?,?,?)\");\r\n, //ps.setDate(3, Calendar.getInstance().getTime());\r\n, // if there wasn't an empty row to begin with\r\n, // now they have a row AND a strike against\r\n]]",
                "generated_comment": "/**\n * Records a login failure for a specific IP address in the database.\n * \n * @param ipAddr the IP address of the user who failed to login\n * @throws DBException if there is an error accessing the database\n */\npublic void recordLoginFailure(String ipAddr) {\n    Connection conn = null;\n    PreparedStatement ps = null;\n    try {\n        conn = factory.getConnection();\n        ps = conn.prepareStatement(\"UPDATE LoginFailures SET FailureCount=FailureCount+1, lastFailure=CURRENT_TIMESTAMP WHERE IPAddress=?\");\n        ps.setString(1, ipAddr);\n        int numUpdated = ps.executeUpdate();\n        if (numUpdated == 0)\n            insertLoginFailureRow(ipAddr, 1, conn);\n    } catch (SQLException e) {\n        e.printStackTrace();\n        throw new DBException(e);\n    } finally {\n        DBUtil.closeConnection(conn, ps);\n    }\n}\n*/"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"UPDATE ResetPasswordFailures SET failurecount=failurecount+1 WHERE ipaddress=?\");\r\n        ps.setString(1, ipAddr);\r\n        int numUpdated = ps.executeUpdate();\r\n        if (// if there wasn't an empty row to begin with\r\n        numUpdated == 0)\r\n            // now they have a row AND a strike against\r\n            insertResetPasswordRow(ipAddr, 1, conn);\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "public void recordResetPasswordFailure(String)",
                "comments": "Optional[/**\r\n * Record a reset password failure, which blacklists the ipAddress. Uses the database table like a hash\r\n * table where the key is the user's IP address. If the user's IP address is not in the table, a row with\r\n * \"1\" is added.\r\n *\r\n * @param ipAddr The IP address of the user as a String.\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": "Optional[[// if there wasn't an empty row to begin with\r\n, // now they have a row AND a strike against\r\n]]",
                "generated_comment": "/**\n * Records a failed attempt to reset a password for a specific IP address. \n * If the IP address already has a record in the database, the failure count is incremented. \n * If the IP address does not have a record, a new record is inserted with a failure count of 1.\n * \n * @param ipAddr the IP address for which the reset password failure is being recorded\n * @throws DBException if there is an error accessing the database\n */"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"SELECT * FROM ResetPasswordFailures WHERE IPADDRESS=?\");\r\n        ps.setString(1, ipAddr);\r\n        ResultSet rs = ps.executeQuery();\r\n        if (rs.next()) {\r\n            // if we're more than X minutes out, clear the failure count\r\n            if (System.currentTimeMillis() - rs.getTimestamp(\"lastFailure\").getTime() > LOGIN_TIMEOUT) {\r\n                updateResetFailuresToZero(ipAddr, conn);\r\n                return 0;\r\n            } else {\r\n                return rs.getInt(\"failureCount\");\r\n            }\r\n        } else {\r\n            insertResetPasswordRow(ipAddr, 0, conn);\r\n            return 0;\r\n        }\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "public int getResetPasswordFailures(String)",
                "comments": "Optional[/**\r\n * Return the number of failures from resetting a password, given an IP address.\r\n *\r\n * @param ipAddr An IP address for the associated attempt as a String.\r\n * @return An int representing the number of failures.\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": "Optional[[// if we're more than X minutes out, clear the failure count\r\n]]",
                "generated_comment": "/**\n * Retrieves the number of reset password failures for a given IP address.\n * If the last failure occurred more than X minutes ago, the failure count is reset to zero.\n * If no record exists for the IP address, a new record is inserted with a failure count of zero.\n * \n * @param ipAddr the IP address for which to retrieve the reset password failures\n * @return the number of reset password failures for the given IP address\n * @throws DBException if there is an error accessing the database\n */"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"SELECT * FROM LoginFailures WHERE IPADDRESS=?\");\r\n        ps.setString(1, ipAddr);\r\n        ResultSet rs = ps.executeQuery();\r\n        if (rs.next()) {\r\n            // if we're more than X minutes out, clear the failure count\r\n            if (System.currentTimeMillis() - rs.getTimestamp(\"lastFailure\").getTime() > LOGIN_TIMEOUT) {\r\n                updateFailuresToZero(ipAddr, conn);\r\n                return 0;\r\n            } else {\r\n                return rs.getInt(\"failureCount\");\r\n            }\r\n        } else {\r\n            insertLoginFailureRow(ipAddr, 0, conn);\r\n            return 0;\r\n        }\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "public int getLoginFailures(String)",
                "comments": "Optional[/**\r\n * Return the number of failures from login failures a password, given an IP address.\r\n *\r\n * @param ipAddr The IP address for this attempt as a String.\r\n * @return An int representing the number of failures which have occured.\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": "Optional[[// if we're more than X minutes out, clear the failure count\r\n]]",
                "generated_comment": "/**\n * Retrieves the number of login failures for a given IP address.\n * If the last failure occurred more than X minutes ago, the failure count is reset to zero.\n * If no record exists for the IP address, a new record with zero failures is inserted.\n * \n * @param ipAddr the IP address for which to retrieve the login failures\n * @return the number of login failures for the specified IP address\n * @throws DBException if an error occurs while accessing the database\n */"
            },
            {
                "body": "Optional[{\r\n    PreparedStatement ps = conn.prepareStatement(\"INSERT INTO LoginFailures(IPAddress, failureCount) VALUES(?,?)\");\r\n    ps.setString(1, ipAddr);\r\n    ps.setInt(2, failureCount);\r\n    ps.executeUpdate();\r\n}]",
                "hasComment": false,
                "hasInnerComment": false,
                "signature": "private void insertLoginFailureRow(String, int, Connection)",
                "comments": null,
                "innerComments": null,
                "generated_comment": "/**\n * Inserts a new row into the LoginFailures table with the given IP address and failure count.\n * \n * @param ipAddr the IP address of the failed login attempt\n * @param failureCount the number of failed login attempts for the given IP address\n * @param conn the database connection\n * \n * @throws SQLException if a database error occurs\n */\nprivate void insertLoginFailureRow(String ipAddr, int failureCount, Connection conn) {\n    try {\n        PreparedStatement ps = conn.prepareStatement(\"INSERT INTO LoginFailures(IPAddress, failureCount) VALUES(?,?)\");\n        ps.setString(1, ipAddr);\n        ps.setInt(2, failureCount);\n        ps.executeUpdate();\n    } catch (SQLException e) {\n        // Handle the database error\n        e.printStackTrace();\n    }\n}"
            },
            {
                "body": "Optional[{\r\n    PreparedStatement ps = conn.prepareStatement(\"INSERT INTO ResetPasswordFailures(IPAddress, failureCount) VALUES(?,?)\");\r\n    ps.setString(1, ipAddr);\r\n    ps.setInt(2, failureCount);\r\n    ps.executeUpdate();\r\n}]",
                "hasComment": false,
                "hasInnerComment": false,
                "signature": "private void insertResetPasswordRow(String, int, Connection)",
                "comments": null,
                "innerComments": null,
                "generated_comment": "/**\n * Inserts a new row into the ResetPasswordFailures table with the given IP address and failure count.\n * \n * @param ipAddr the IP address to insert into the table\n * @param failureCount the number of failures associated with the IP address\n * @param conn the database connection to use for the insertion\n * \n * @throws SQLException if a database error occurs\n */\nprivate void insertResetPasswordRow(String ipAddr, int failureCount, Connection conn) {\n    try {\n        PreparedStatement ps = conn.prepareStatement(\"INSERT INTO ResetPasswordFailures(IPAddress, failureCount) VALUES(?,?)\");\n        ps.setString(1, ipAddr);\n        ps.setInt(2, failureCount);\n        ps.executeUpdate();\n    } catch (SQLException e) {\n        // Handle the exception\n    }\n}"
            },
            {
                "body": "Optional[{\r\n    PreparedStatement ps = conn.prepareStatement(\"UPDATE LoginFailures SET failureCount=0 WHERE IPAddress=?\");\r\n    ps.setString(1, ipAddr);\r\n    ps.executeUpdate();\r\n}]",
                "hasComment": false,
                "hasInnerComment": false,
                "signature": "private void updateFailuresToZero(String, Connection)",
                "comments": null,
                "innerComments": null,
                "generated_comment": "/**\n * Updates the failure count to zero for a specific IP address in the LoginFailures table.\n * \n * @param ipAddr the IP address for which the failure count needs to be updated to zero\n * @param conn the database connection to be used for updating the failure count\n * \n * @throws SQLException if a database access error occurs\n */\n \nNote: Since this method has a return type of void, there is no return value to be documented."
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"UPDATE LoginFailures SET failureCount=0 WHERE IPAddress=?\");\r\n        ps.setString(1, ipAddr);\r\n        ps.executeUpdate();\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": false,
                "hasInnerComment": false,
                "signature": "public void resetLoginFailuresToZero(String)",
                "comments": null,
                "innerComments": null,
                "generated_comment": "/**\n * Resets the login failures count to zero for a specific IP address in the database.\n * \n * @param ipAddr the IP address for which the login failures count needs to be reset\n * @throws DBException if there is an error accessing the database\n */\npublic void resetLoginFailuresToZero(String ipAddr) {\n    Connection conn = null;\n    PreparedStatement ps = null;\n    try {\n        conn = factory.getConnection();\n        ps = conn.prepareStatement(\"UPDATE LoginFailures SET failureCount=0 WHERE IPAddress=?\");\n        ps.setString(1, ipAddr);\n        ps.executeUpdate();\n    } catch (SQLException e) {\n        e.printStackTrace();\n        throw new DBException(e);\n    } finally {\n        DBUtil.closeConnection(conn, ps);\n    }\n}\n*/"
            },
            {
                "body": "Optional[{\r\n    PreparedStatement ps = conn.prepareStatement(\"UPDATE ResetPasswordFailures SET failureCount=0 WHERE IPAddress=?\");\r\n    ps.setString(1, ipAddr);\r\n    ps.executeUpdate();\r\n}]",
                "hasComment": false,
                "hasInnerComment": false,
                "signature": "private void updateResetFailuresToZero(String, Connection)",
                "comments": null,
                "innerComments": null,
                "generated_comment": "/**\n * Updates the failure count to zero in the ResetPasswordFailures table for a specific IP address.\n * \n * @param ipAddr the IP address for which the failure count needs to be reset to zero\n * @param conn the Connection object to the database\n * \n * @throws SQLException if a database access error occurs\n */"
            },
            {
                "body": "Optional[{\r\n    Connection conn = null;\r\n    PreparedStatement ps = null;\r\n    try {\r\n        conn = factory.getConnection();\r\n        ps = conn.prepareStatement(\"SELECT * FROM Users WHERE MID=?\");\r\n        ps.setLong(1, mid);\r\n        ResultSet rs = ps.executeQuery();\r\n        return rs.next();\r\n    } catch (SQLException e) {\r\n        e.printStackTrace();\r\n        throw new DBException(e);\r\n    } finally {\r\n        DBUtil.closeConnection(conn, ps);\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public boolean checkUserExists(long)",
                "comments": "Optional[/**\r\n * Check that a user actually exists.\r\n *\r\n * @param mid\r\n * @return\r\n * @throws DBException\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Checks if a user with the specified MID exists in the database.\n * \n * @param mid the MID of the user to check for existence\n * @return true if a user with the specified MID exists, false otherwise\n * @throws DBException if there is an error accessing the database\n */"
            }
        ],
        "constructors": [
            {
                "body": "{\r\n    this.factory = factory;\r\n}",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "public AuthDAO(DAOFactory)",
                "comments": "Optional[/**\r\n * The typical constructor.\r\n * @param factory The {@link DAOFactory} associated with this DAO, which is used for obtaining SQL connections, etc.\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Constructs a new AuthDAO with the specified DAOFactory.\n * \n * @param factory the DAOFactory to be used by this AuthDAO\n * @throws IllegalArgumentException if the factory is null\n */\npublic AuthDAO(DAOFactory factory) {\n    if (factory == null) {\n        throw new IllegalArgumentException(\"Factory cannot be null\");\n    }\n    \n    this.factory = factory;\n}"
            }
        ],
        "signature": "AuthDAO",
        "variables": [
            "public  static  final long LOGIN_TIMEOUT",
            "private DAOFactory factory"
        ],
        "generated_class_comment": "/**\n * The AuthDAO class provides data access methods for managing user authentication and security features in the database.\n * It includes methods for adding users, setting security questions and answers, retrieving user roles and names,\n * resetting passwords, recording login and reset password failures, and checking user existence.\n * \n * The class contains constructors for initializing the DAOFactory used for obtaining database connections.\n * \n * The main functionalities of the AuthDAO class include:\n * - Adding a new user with a randomly generated password\n * - Setting security questions and answers for users\n * - Retrieving user roles and names based on user IDs\n * - Resetting user passwords\n * - Recording login and reset password failures for IP addresses\n * - Checking the existence of users in the database\n * \n * The class also includes methods for inserting and updating records in the LoginFailures and ResetPasswordFailures tables.\n * \n * Note: The class defines a constant LOGIN_TIMEOUT for managing timeout thresholds for login and reset password failures.\n */\n \npublic class AuthDAO {\n    public static final long LOGIN_TIMEOUT;\n    private DAOFactory factory;\n    \n    /**\n     * Constructs a new AuthDAO with the specified DAOFactory.\n     * \n     * @param factory the DAOFactory to be used by this AuthDAO\n     * @throws IllegalArgumentException if the factory is null\n     */\n    public AuthDAO(DAOFactory factory) {\n        if (factory == null) {\n            throw new IllegalArgumentException(\"Factory cannot be null\");\n        }\n        \n        this.factory = factory;\n    }\n    \n    /**\n     * Add a particular user to the system. Does not add user-specific information (e.g. Patient or HCP).\n     * Initially sets security question to a random set of characters, so that nobody should be able to guess its value.\n     * \n     * @param mid The user's MID as a Long.\n     * @param role The role of the user as a Role enum {@link Role}\n     * @param password The password for the new user.\n     * @return A string representing the newly added randomly-generated password.\n     * @throws DBException\n     */\n    public String addUser(Long mid, Role role, String password) {\n        // Method body implementation\n    }\n    \n    /**\n     * Reset the security question and answer for a particular user\n     * \n     * @param question The security question as a string.\n     * @param answer The security answer as a string.\n     * @param mid The MID of the user as a long.\n     * @throws DBException\n     */\n    public void setSecurityQuestionAnswer(String question, String answer, long mid) {\n        // Method body implementation\n    }\n    \n    /**\n     * Returns the user name of a user from just the MID\n     * \n     * @param mid The MID of the user to get the name of.\n     * @return The user's name as a String.\n     * @throws DBException\n     * @throws iTrustException\n     */\n    public String getUserName(long mid) {\n        // Method body implementation\n    }\n    \n    /**\n     * Returns the role of a particular MID\n     * \n     * @param mid The MID of the user to look up.\n     * @return The {@link Role} of the user as an enum.\n     * @throws DBException\n     * @throws iTrustException\n     */\n    public Role getUserRole(long mid) {\n        // Method body implementation\n    }\n    \n    /**\n     * Change the password of a particular user\n     * \n     * @param mid The MID of the user whose password we are changing.\n     * @param password The new password.\n     * @throws DBException\n     */\n    public void resetPassword(long mid, String password) {\n        // Method body implementation\n    }\n    \n    /**\n     * Return the security question for a particular user.\n     * \n     * @param mid The MID of the user we are looking up.\n     * @return The security question of the user we are looking up.\n     * @throws iTrustException\n     */\n    public String getSecurityQuestion(long mid) {\n        // Method body implementation\n    }\n    \n    /**\n     * Return the security answer of a particular user\n     * \n     * @param mid The MID of the user we are looking up.\n     * @return The security answer as a String.\n     * @throws iTrustException\n     */\n    public String getSecurityAnswer(long mid) {\n        // Method body implementation\n    }\n    \n    /**\n     * Record a login failure, which blacklists the ipAddress. Uses the database table like a hash table where\n     * the key is the user's IP address. If the user's IP address is not in the table, a row with \"1\" is added.\n     * \n     * @param ipAddr The IP address of the user as a String.\n     * @throws DBException\n     */\n    public void recordLoginFailure(String ipAddr) {\n        // Method body implementation\n    }\n    \n    /**\n     * Record a reset password failure, which blacklists the ipAddress. Uses the database table like a hash\n     * table where the key is the user's IP address. If the user's IP address is not in the table, a row with\n     * \"1\" is added.\n     * \n     * @param ipAddr The IP address of the user as a String.\n     * @throws DBException\n     */\n    public void recordResetPasswordFailure(String ipAddr) {\n        // Method body implementation\n    }\n    \n    /**\n     * Return the number of failures from resetting a password, given an IP address.\n     * \n     * @param ipAddr An IP address for the associated attempt as a String.\n     * @return An int representing the number of failures.\n     * @throws DBException\n     */\n    public int getResetPasswordFailures(String ipAddr) {\n        // Method body implementation\n    }\n    \n    /**\n     * Return the number of failures from login failures a password, given an IP address.\n     * \n     * @param ipAddr The IP address for this attempt as a String.\n     * @return An int representing the number of failures which have occured.\n     * @throws DBException\n     */\n    public int getLoginFailures(String ipAddr) {\n        // Method body implementation\n    }\n    \n    /**\n     * Inserts a new row into the LoginFailures table with the given IP address and failure count.\n     * \n     * @param ipAddr the IP address of the failed login attempt\n     * @param failureCount the number of failed login attempts for the given IP address\n     * @param conn the database connection\n     * \n     * @throws SQLException if a database error occurs\n     */\n    private void insertLoginFailureRow(String ipAddr, int failureCount, Connection conn) {\n        // Method body implementation\n    }\n    \n    /**\n     * Inserts a new row into the ResetPasswordFailures table with the given IP address and failure count.\n     * \n     * @param ipAddr the IP address to insert into the table\n     * @param failureCount the number of failures associated with the IP address\n     * @param conn the database connection to use for the insertion\n     * \n     * @throws SQLException if a database error occurs\n     */\n    private void insertResetPasswordRow(String ipAddr, int failureCount, Connection conn) {\n        // Method body implementation\n    }\n    \n    /**\n     * Updates the failure count to zero for a specific IP address in the LoginFailures table.\n     * \n     * @param ipAddr the IP address for which the failure count needs to be updated to zero\n     * @param conn the database connection to be used for updating the failure count\n     * \n     * @throws SQLException if a database access error occurs\n     */\n    private void updateFailuresToZero(String ipAddr, Connection conn) {\n        // Method body implementation\n    }\n    \n    /**\n     * Resets the login failures count to zero for a specific IP address in the database.\n     * \n     * @param ipAddr the IP address for which the login failures count needs to be reset\n     * @throws DBException if there is an error accessing the database\n     */\n    public void resetLoginFailuresToZero(String ipAddr) {\n        // Method body implementation\n    }\n    \n    /**\n     * Updates the failure count to zero in the ResetPasswordFailures table for a specific IP address.\n     * \n     * @param ipAddr the IP address for which the failure count needs to be reset to zero\n     * @param conn the Connection object to the database\n     * \n     * @throws SQLException if a database access error occurs\n     */\n    private void updateResetFailuresToZero(String ipAddr, Connection conn) {\n        // Method body implementation\n    }\n    \n    /**\n     * Check that a user actually exists.\n     * \n     * @param mid\n     * @return\n     * @throws DBException\n     */\n    public boolean checkUserExists(long mid) {\n        // Method body implementation\n    }\n}\n*/"
    }
]