[
    {
        "methods": [
            {
                "body": "Optional[{\r\n    return (distance / pMaxDist);\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "private static float relevance(float, float)",
                "comments": "Optional[/**\r\n * Method for calculating the relevance of a term.\r\n *\r\n * @param distance: Contains the distance of the term from category\r\n *                  Analyzed\r\n * @param pMaxDist: Contains distaza maximum of all terms in all\r\n *                  Categories.\r\n * @return Returns the relevance of the term in the category.\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Calculates the relevance of a given distance based on the maximum distance.\n * \n * @param distance the distance to calculate relevance for\n * @param pMaxDist the maximum distance allowed\n * @return the relevance of the distance as a float value between 0 and 1\n */"
            },
            {
                "body": "Optional[{\r\n    // The first variable tracks the frequency of a term\r\n    // Relating to a category\r\n    // The second keeps track of frequency for all\r\n    // Categories\r\n    float[] frequenzaCategoria = new float[3], frequenzaTotale = new float[3];\r\n    if (pCategoria.esisteTermine(pTermine)) {\r\n        // if the term is\r\n        // In category\r\n        // Its frequency in this category is equal to the frequency\r\n        // KnowledgeBase\r\n        // More frequency in the search text\r\n        frequenzaCategoria = pCategoria.getVal(pTermine);\r\n        frequenzaCategoria[0] += frequenzaTesto;\r\n    } else {\r\n        // Otherwise it is equal to the frequency of the term in the text\r\n        // Analyzed\r\n        frequenzaCategoria[0] = frequenzaTesto;\r\n    }\r\n    if (pTotTermini.get(pTermine) != null) {\r\n        // if the term exists in\r\n        // Table of the total time\r\n        // Get the value\r\n        frequenzaTotale = pTotTermini.get(pTermine);\r\n        // the total frequency is given\r\n        frequenzaTotale[0] += frequenzaTesto;\r\n        // Frequency in the text\r\n        // Analyzed\r\n        // Plus any frequency stored in memory in the table\r\n        // Total time\r\n    }\r\n    // distance is\r\n    return (frequenzaCategoria[0] / frequenzaTotale[0]);\r\n    // Equal to\r\n    // Frequency in\r\n    // Category\r\n    // The total frequency\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "private static float distance(String, Hashtable<String, float[]>, float, Category)",
                "comments": "Optional[/**\r\n * Method for calculating the distance between a term and a category\r\n *\r\n * @param pTermine: Contains the period analyzed\r\n * @param pTotTermini: Tables of the total frequency of terms.\r\n * @param frequenzaTesto: Table of the terms of the text analyzed.\r\n * @param pCategoria: Category analyzed.\r\n * @return Returns the distance of the term pTermine by category\r\n *         pCategoria\r\n */\r\n]",
                "innerComments": "Optional[[// The first variable tracks the frequency of a term\r\n, // Relating to a category\r\n, // The second keeps track of frequency for all\r\n, // Equal to\r\n, // Frequency in\r\n, // Category\r\n, // The total frequency\r\n, // Categories\r\n, // if the term is\r\n, // In category\r\n, // Its frequency in this category is equal to the frequency\r\n, // KnowledgeBase\r\n, // More frequency in the search text\r\n, // Otherwise it is equal to the frequency of the term in the text\r\n, // Analyzed\r\n, // if the term exists in\r\n, // Table of the total time\r\n, // Frequency in the text\r\n, // Analyzed\r\n, // Plus any frequency stored in memory in the table\r\n, // Total time\r\n, // Get the value\r\n, // the total frequency is given\r\n, // distance is\r\n]]",
                "generated_comment": "/**\n * Calculates the distance between a given term and a category based on the frequency of the term in the category and the total frequency of the term across all categories.\n * \n * @param pTermine The term for which the distance is being calculated.\n * @param pTotTermini A Hashtable containing the total frequency of the term across all categories.\n * @param frequenzaTesto The frequency of the term in the text being analyzed.\n * @param pCategoria The category for which the distance is being calculated.\n * @return The distance between the term and the category, calculated as the frequency of the term in the category divided by the total frequency of the term across all categories.\n */\nprivate static float distance(String pTermine, Hashtable<String, float[]> pTotTermini, float frequenzaTesto, Category pCategoria) {\n    // Method body as described above\n}\n**/"
            },
            {
                "body": "Optional[{\r\n    return ((pCategoria.getVal(pTermine))[0] / (pTotTermini.get(pTermine))[0]);\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "private static float distance(String, Category, Hashtable<String, float[]>)",
                "comments": "Optional[/**\r\n * Method for calculating the distance of a term from one category.\r\n * Used for training\r\n *\r\n * @param pTermine period to analyze\r\n * @param pCategoria category from which you must calculate the distance\r\n * @param pTotTermini total time\r\n * @return Returns the distance of a term from one category\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Calculates the distance between a given term and a category using the values stored in the provided Hashtable.\n * The distance is calculated as the absolute difference between the first element of the float array associated with the term in the category and the first element of the float array associated with the term in the total terms Hashtable.\n * \n * @param pTermine the term for which the distance is being calculated\n * @param pCategoria the category to which the term belongs\n * @param pTotTermini the Hashtable containing all terms and their corresponding float arrays\n * @return the calculated distance as a float value\n */"
            },
            {
                "body": "Optional[{\r\n    return ((a * b) / ((2 - ((a + b) - (a * b)))));\r\n    // Return Math.min(a, b);\r\n    // Return a * b;\r\n    // Return Math.max(0, a + b - 1);\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "private static float tNorm(float, float)",
                "comments": "Optional[/**\r\n * Implementation of a function T-Norm\r\n *\r\n * @param a first value\r\n * @param b the second value\r\n * @return returns the value calculated using a function T-Norm\r\n */\r\n]",
                "innerComments": "Optional[[// Return Math.min(a, b);\r\n, // Return a * b;\r\n, // Return Math.max(0, a + b - 1);\r\n]]",
                "generated_comment": "/**\n * Calculates the T-norm (also known as the algebraic product) of two floating-point numbers.\n * The T-norm is defined as (a * b) / (2 - (a + b - (a * b))).\n * \n * @param a the first floating-point number\n * @param b the second floating-point number\n * @return the result of the T-norm calculation\n */"
            },
            {
                "body": "Optional[{\r\n    return ((a + b) / (1 + a * b));\r\n    // Return Math.max(a, b);\r\n    // Return (a + b - (a * b));\r\n    // Return Math.min(1, a + b);\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "private static float sNorm(float, float)",
                "comments": "Optional[/**\r\n * Implementation of a function S-Norm\r\n *\r\n * @param a first value\r\n * @param b the second value\r\n * @return returns the value calculated using a function S-Norm\r\n */\r\n]",
                "innerComments": "Optional[[// Return Math.max(a, b);\r\n, // Return (a + b - (a * b));\r\n, // Return Math.min(1, a + b);\r\n]]",
                "generated_comment": "/**\n * Calculates the normalized sum of two floating point numbers.\n * \n * @param a the first floating point number\n * @param b the second floating point number\n * @return the normalized sum of the two input numbers, calculated as ((a + b) / (1 + a * b))\n */"
            },
            {
                "body": "Optional[{\r\n    // return value\r\n    float sum = 0;\r\n    for (float[] val : pTermini.values()) {\r\n        // for all elements of\r\n        // Table\r\n        // performs\r\n        sum += (tNorm(val[1], val[0])) / (sNorm(val[1], val[0]));\r\n        // Sum of the values given by the division of function T-Norm\r\n        // With the function S-Norm made\r\n        // Between relevance and belonging\r\n    }\r\n    return sum;\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "private static float similarity(Hashtable<String, float[]>)",
                "comments": "Optional[/**\r\n * Calculation of similarity between a category and a given text input\r\n *\r\n * @param pTermini worded. It must contain to\r\n *                  each term values of importance and belonging situated in\r\n *                  float[] in positions 1 and 2.\r\n * @return returns a numeric value that indicates the similarity of a\r\n *         Text with the category on which one has calculated the values of\r\n *         Importance and belonging\r\n */\r\n]",
                "innerComments": "Optional[[// return value\r\n, // for all elements of\r\n, // Table\r\n, // Sum of the values given by the division of function T-Norm\r\n, // With the function S-Norm made\r\n, // Between relevance and belonging\r\n, // performs\r\n]]",
                "generated_comment": "/**\n * Calculates the similarity between two sets of float arrays using the T-Norm and S-Norm functions.\n * \n * @param pTermini a Hashtable containing String keys and float array values representing the sets to compare\n * @return the similarity value calculated by summing the division of T-Norm and S-Norm values for each element in the Hashtable\n */"
            },
            {
                "body": "Optional[{\r\n    return (val / maxSimilarity);\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "private static float membership(float, float)",
                "comments": "Optional[/**\r\n * Method for the calculation of membership of a text to a category\r\n *\r\n * @param val indicates the similarity of a text with a category\r\n * @param maxSimilarity indicates the maximum similarity found\r\n * @return returns a value in the interval [0,1] that indicates the degree of\r\n *         Membership of the text to the category\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Calculates the membership value of a given similarity score based on the maximum similarity score.\n * \n * @param val the similarity score to calculate the membership value for\n * @param maxSimilarity the maximum similarity score possible\n * @return the membership value of the similarity score, calculated as val divided by maxSimilarity\n */"
            },
            {
                "body": "Optional[{\r\n    pStr = pStr.toLowerCase();\r\n    pStr = pStr.replace(\",\", \"\");\r\n    pStr = pStr.replace(\".\", \"\");\r\n    pStr = pStr.replace(\"!\", \"\");\r\n    pStr = pStr.replace(\"?\", \"\");\r\n    pStr = pStr.replace(\"'\", \"\");\r\n    return pStr;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "private static String replaceAndLower(String)",
                "comments": "Optional[/**\r\n * Method to delete special characters and to bring\r\n * All uppercase to lowercase\r\n *\r\n * @param pStr string to transform\r\n * @return returns the text to lowercase characters and no special\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * This method takes a String input and returns a new String with all punctuation marks removed and all letters converted to lowercase.\n * \n * @param pStr the input String to be processed\n * @return a new String with all punctuation marks removed and all letters converted to lowercase\n */"
            },
            {
                "body": "Optional[{\r\n    if ((pDescrizione == null) || (pDescrizione.equals(\"\")))\r\n        return \"NULL\";\r\n    String text = pDescrizione;\r\n    // Table of terms associated with the text portion. Will contain\r\n    // Values of frequency, relevance, membership for each term\r\n    Hashtable<String, float[]> datiTesto = new Hashtable<>();\r\n    // Table of categories, each category will contain the value of\r\n    // Similarity and belonging Text\r\n    Hashtable<String, float[]> testoCategoria = new Hashtable<>();\r\n    // delete characters and special\r\n    text = replaceAndLower(text);\r\n    // Returns the text by replacing\r\n    // Uppercase with lowercase\r\n    String[] testoSplit = text.split(\" \");\r\n    for (int i = 0; i < testoSplit.length; i++) {\r\n        // For each end of the text\r\n        // value to assign to the string\r\n        float[] toPut = new float[3];\r\n        // In the hash table\r\n        // temporary variable containing the values\r\n        float[] valTmp;\r\n        // Associated with the string if it already exists in the hash table\r\n        // If the string is present in the table picks up the values\r\n        // And increases by saving them in toPut\r\n        // Otherwise initialize the new string with frequency = 1\r\n        if (// delete undefined terms\r\n        testoSplit[i].length() <= 3)\r\n            // As important, the inter ...\r\n            continue;\r\n        if (exists(testoSplit[i], datiTesto)) {\r\n            // if the time analyzed\r\n            // Is present in table the terms of the analyzed text\r\n            // We get the value of frequency in the table and there\r\n            // Adds one\r\n            valTmp = datiTesto.get(testoSplit[i]);\r\n            toPut[0] = valTmp[0];\r\n            toPut[0] += (float) 1 / testoSplit.length;\r\n        } else {\r\n            // Otherwise initialize the value of frequency to a\r\n            toPut[0] = (float) 1 / testoSplit.length;\r\n            // Fratto, the total number of terms (relative frequency)\r\n        }\r\n        // Insert the new entry in the table\r\n        // System.out.println(toPut[0]);\r\n        datiTesto.put(testoSplit[i], toPut);\r\n    }\r\n    // You try to open the knowledge base\r\n    ElencoCategorie list;\r\n    try {\r\n        list = apriElenco();\r\n    } catch (ClassNotFoundException e) {\r\n        // error opening file kb.sbt\r\n        throw new RemoteException(\"The knowledge base is missing or corrupt\");\r\n    } catch (Exception e) {\r\n        throw new RemoteException(\"The knowledge base is missing or corrupt\");\r\n    }\r\n    // Is taken from the base of knowledge to the table of total time\r\n    Hashtable<String, float[]> totTermini = list.getTotTermini();\r\n    // holds the value of maximum similarity\r\n    float maxSimilarity = -1;\r\n    for (String CategoryName : list.Categorie()) {\r\n        // For all the categories in the knowledge base\r\n        // value to assign to the string\r\n        float[] toPut = new float[3];\r\n        // In the hash table\r\n        for (Enumeration<String> val = datiTesto.keys(); val.hasMoreElements(); ) {\r\n            // For all elements of the table of the terms of the text\r\n            String term = val.nextElement();\r\n            // We get the value of a term\r\n            float[] tmp = datiTesto.get(term);\r\n            // Calculate range and bearing\r\n            tmp[1] = distance(term, totTermini, tmp[0], list.getCategoria(CategoryName));\r\n            tmp[2] = relevance(tmp[1], list.getMaxDist());\r\n            datiTesto.put(term, tmp);\r\n        }\r\n        // We calculate the similarity Once the analysis\r\n        // All the terms in a category\r\n        toPut[0] = similarity(datiTesto);\r\n        testoCategoria.put(CategoryName, toPut);\r\n        if (maxSimilarity < toPut[0]) {\r\n            // we update the value of maximum\r\n            // If necessary similarity\r\n            maxSimilarity = toPut[0];\r\n        }\r\n    }\r\n    for (String CategoryName : list.Categorie()) {\r\n        // For each category\r\n        // We get the value of similarity of the text with the category\r\n        // Analyzed\r\n        float[] tmp = testoCategoria.get(CategoryName);\r\n        // we calculate\r\n        tmp[1] = membership(tmp[0], maxSimilarity);\r\n        // Membership\r\n        // Text to the similarity\r\n        // save everything in\r\n        testoCategoria.put(CategoryName, tmp);\r\n        // Category table\r\n    }\r\n    // returns the name output\r\n    return maxAppartenenza(testoCategoria);\r\n    // Category\r\n    // With the maximum degree of membership\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "public static String calcolaCategoria(String)",
                "comments": "Optional[/**\r\n * Method of retrieving the category you belong to a text\r\n *\r\n * @param pDescrizione text to analyze\r\n * @return a string indicating the category\r\n * @throws RemoteException\r\n */\r\n]",
                "innerComments": "Optional[[// Table of terms associated with the text portion. Will contain\r\n, // Table of categories, each category will contain the value of\r\n, // Returns the text by replacing\r\n, // Category\r\n, // With the maximum degree of membership\r\n, // Values of frequency, relevance, membership for each term\r\n, // Similarity and belonging Text\r\n, // delete characters and special\r\n, // Uppercase with lowercase\r\n, // For each end of the text\r\n, // In the hash table\r\n, // Associated with the string if it already exists in the hash table\r\n, // If the string is present in the table picks up the values\r\n, // And increases by saving them in toPut\r\n, // Insert the new entry in the table\r\n, // value to assign to the string\r\n, // temporary variable containing the values\r\n, // Otherwise initialize the new string with frequency = 1\r\n, // delete undefined terms\r\n, // As important, the inter ...\r\n, // if the time analyzed\r\n, // Is present in table the terms of the analyzed text\r\n, // We get the value of frequency in the table and there\r\n, // Adds one\r\n, // Fratto, the total number of terms (relative frequency)\r\n, // Otherwise initialize the value of frequency to a\r\n, // System.out.println(toPut[0]);\r\n, // You try to open the knowledge base\r\n, // error opening file kb.sbt\r\n, // Is taken from the base of knowledge to the table of total time\r\n, // holds the value of maximum similarity\r\n, // For all the categories in the knowledge base\r\n, // We calculate the similarity Once the analysis\r\n, // value to assign to the string\r\n, // In the hash table\r\n, // For all elements of the table of the terms of the text\r\n, // We get the value of a term\r\n, // Calculate range and bearing\r\n, // All the terms in a category\r\n, // we update the value of maximum\r\n, // If necessary similarity\r\n, // For each category\r\n, // We get the value of similarity of the text with the category\r\n, // Membership\r\n, // Text to the similarity\r\n, // Category table\r\n, // Analyzed\r\n, // we calculate\r\n, // save everything in\r\n, // returns the name output\r\n]]",
                "generated_comment": "/**\n * This method calculates the category of a given text based on the frequency, relevance, and membership of terms within the text.\n * \n * @param pDescrizione The input text for which the category needs to be determined.\n * @return The category with the maximum degree of membership based on the analysis of terms in the input text.\n */\npublic static String calcolaCategoria(String pDescrizione) {\n    // Method body implementation as described above\n}\n*/"
            },
            {
                "body": "Optional[{\r\n    // return value\r\n    String toReturn = null;\r\n    // Maximum value of membership\r\n    float max = -1;\r\n    for (Enumeration<String> elm = pTestoCategoria.keys(); elm.hasMoreElements(); ) {\r\n        // For all categories of the table of categories of text\r\n        String category = elm.nextElement();\r\n        // Values are taken of similarity and belonging associated with\r\n        // Category\r\n        float[] tmp = pTestoCategoria.get(category);\r\n        if (tmp[1] > max) {\r\n            // If the degree of membership affiliation just uploaded\r\n            // Is greater than the previous update data max and toReturn\r\n            toReturn = category;\r\n            max = tmp[1];\r\n        }\r\n    }\r\n    return toReturn;\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "private static String maxAppartenenza(Hashtable<String, float[]>)",
                "comments": "Optional[/**\r\n * Method to find the category with which the text has the highest degree of\r\n * Membership\r\n *\r\n * @param pTestoCategoria table of categories to the text\r\n * @return a string indicating the name of the category with which\r\n *         The text has the highest degree of membership\r\n */\r\n]",
                "innerComments": "Optional[[// return value\r\n, // Maximum value of membership\r\n, // Values are taken of similarity and belonging associated with\r\n, // For all categories of the table of categories of text\r\n, // Category\r\n, // If the degree of membership affiliation just uploaded\r\n, // Is greater than the previous update data max and toReturn\r\n]]",
                "generated_comment": "/**\n * Finds the category with the maximum degree of membership in a given Hashtable.\n * \n * @param pTestoCategoria a Hashtable containing categories as keys and float arrays representing similarity and membership values as values\n * @return the category with the highest degree of membership, or null if the Hashtable is empty\n */\nprivate static String maxAppartenenza(Hashtable<String, float[]> pTestoCategoria) {\n    // return value\n    String toReturn = null;\n    // Maximum value of membership\n    float max = -1;\n    for (Enumeration<String> elm = pTestoCategoria.keys(); elm.hasMoreElements(); ) {\n        // For all categories of the table of categories of text\n        String category = elm.nextElement();\n        // Values are taken of similarity and belonging associated with\n        // Category\n        float[] tmp = pTestoCategoria.get(category);\n        if (tmp[1] > max) {\n            // If the degree of membership affiliation just uploaded\n            // Is greater than the previous update data max and toReturn\n            toReturn = category;\n            max = tmp[1];\n        }\n    }\n    return toReturn;\n}\n*/"
            },
            {
                "body": "Optional[{\r\n    try {\r\n        if (pTable.get(pStr) != null)\r\n            return true;\r\n    } catch (NullPointerException e) {\r\n        return false;\r\n    }\r\n    return false;\r\n}]",
                "hasComment": true,
                "hasInnerComment": false,
                "signature": "private static boolean exists(String, Hashtable<String, float[]>)",
                "comments": "Optional[/**\r\n * Method used to check whether a term is presented in the table\r\n * The terms of the text\r\n *\r\n * @param pStr period to analyze\r\n * @param pTable tables in terms of the text\r\n * @return returns true if the term exists false otherwise\r\n */\r\n]",
                "innerComments": null,
                "generated_comment": "/**\n * Checks if a given key exists in the provided Hashtable.\n * \n * @param pStr the key to check for existence in the Hashtable\n * @param pTable the Hashtable to search for the key in\n * @return true if the key exists in the Hashtable, false otherwise\n */"
            },
            {
                "body": "Optional[{\r\n    // you open the file kb.sbt\r\n    File kBase = new File(\"kb.sbt\");\r\n    // creates\r\n    FileInputStream kBaseStream = new FileInputStream(kBase);\r\n    // A stream with the file\r\n    // create a stream object with the file\r\n    ObjectInputStream kBaseObj = new ObjectInputStream(kBaseStream);\r\n    ElencoCategorie toReturn;\r\n    // Object is extracted and saved in the file returned in output\r\n    toReturn = (ElencoCategorie) kBaseObj.readObject();\r\n    return toReturn;\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "private static ElencoCategorie apriElenco()",
                "comments": "Optional[/**\r\n * Method used to retrieve the knowledge base\r\n *\r\n * @return an object representing the type ElencoCategorie\r\n *         KnowledgeBase\r\n * @throws IOException\r\n * @throws ClassNotFoundException\r\n */\r\n]",
                "innerComments": "Optional[[// A stream with the file\r\n, // you open the file kb.sbt\r\n, // creates\r\n, // create a stream object with the file\r\n, // Object is extracted and saved in the file returned in output\r\n]]",
                "generated_comment": "/**\n * Opens the file \"kb.sbt\" and reads an object of type ElencoCategorie from it.\n * \n * @return An ElencoCategorie object containing the data read from the file \"kb.sbt\"\n * @throws IOException if an I/O error occurs while reading the file\n * @throws ClassNotFoundException if the class of a serialized object cannot be found\n */"
            },
            {
                "body": "Optional[{\r\n    ObjectOutputStream toReturn;\r\n    // file is created\r\n    File f = new File(path);\r\n    if (f.exists())\r\n        f.delete();\r\n    FileOutputStream fout = new FileOutputStream(path);\r\n    // create the stream\r\n    toReturn = new ObjectOutputStream(fout);\r\n    return toReturn;\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "private static ObjectOutputStream createFile(String)",
                "comments": "Optional[/**\r\n * Method used to create the file. Used in training\r\n *\r\n * @param path string indicating the path in which to create the file\r\n * @return returns an ObjectOutputStream to the file created\r\n * @throws IOException\r\n */\r\n]",
                "innerComments": "Optional[[// file is created\r\n, // create the stream\r\n]]",
                "generated_comment": "/**\n * Creates a new ObjectOutputStream for writing to a file specified by the given path.\n * If a file already exists at the specified path, it will be deleted before creating a new file.\n * \n * @param path the path to the file to be created\n * @return the created ObjectOutputStream for writing to the file\n * @throws IOException if an I/O error occurs while creating the file or ObjectOutputStream\n */"
            },
            {
                "body": "Optional[{\r\n    // array containing names\r\n    String[] elencoCategorie = new String[4];\r\n    // Of categories to be analyzed\r\n    // Knowledge base\r\n    ElencoCategorie list = new ElencoCategorie();\r\n    ObjectOutputStream elencoOut;\r\n    try {\r\n        // Try to create the file\r\n        elencoOut = createFile(\"kb.sbt\");\r\n    } catch (Exception e) {\r\n        throw new RemoteException(\"Error creating file kb.sbt\");\r\n    }\r\n    elencoCategorie[0] = \"art\";\r\n    elencoCategorie[1] = \"cinema\";\r\n    elencoCategorie[2] = \"sport\";\r\n    // elencoCategorie[3] = \"\";\r\n    for (int i = 0; i < 3; i++) {\r\n        // for each category\r\n        // Create a new object of type Category, which will contain all\r\n        // Category data to be analyzed\r\n        Category toPutCat = new Category(elencoCategorie[i]);\r\n        // If the inclusion of the category in the table of categories\r\n        // Not successful\r\n        // We throw an exception\r\n        if (!list.addCategoria(elencoCategorie[i], toPutCat)) {\r\n            throw new RemoteException(\"Error creating data of category \" + elencoCategorie[i]);\r\n        }\r\n        // You try to read from the folder containing the lyrics of a\r\n        // Category\r\n        // 100 sample test\r\n        for (Integer j = 1; j <= 100; j++) {\r\n            // Path of the folder category\r\n            String path = \"kb/\" + elencoCategorie[i] + \"/\" + j.toString();\r\n            // Try to read the file ith\r\n            FileReader testoReader;\r\n            try {\r\n                testoReader = new FileReader(path);\r\n            } catch (FileNotFoundException e) {\r\n                // If the file does not exist it continues execution from\r\n                // File i +1\r\n                // System.out.println(\"Error on file\" + path);\r\n                continue;\r\n            }\r\n            Scanner testoScanner = new Scanner(testoReader);\r\n            while (testoScanner.hasNextLine()) {\r\n                // Read the text file line by line\r\n                String txt = testoScanner.nextLine();\r\n                txt = replaceAndLower(txt);\r\n                String[] toIterate = txt.split(\" \");\r\n                for (int k = 0; k < toIterate.length; k++) {\r\n                    // For each end of the line\r\n                    if (// remove the effect\r\n                    toIterate[k].length() <= 3)\r\n                        // Undefined terms\r\n                        // Relevant\r\n                        continue;\r\n                    float[] valTerm, valTotTerm;\r\n                    // If the term is present in the table of terms\r\n                    // The class analyzed\r\n                    if (list.getCategoria(elencoCategorie[i]).esisteTermine(toIterate[k])) {\r\n                        // Its frequency is equal to the value stored in\r\n                        // Table plus one fratto the total number of\r\n                        // Terms of the text\r\n                        valTerm = list.getCategoria(elencoCategorie[i]).getVal(toIterate[k]);\r\n                        valTerm[0] += (float) 1 / toIterate.length;\r\n                        valTotTerm = list.getTermine(toIterate[k]);\r\n                        valTotTerm[0] += (float) 1 / toIterate.length;\r\n                    } else {\r\n                        // otherwise it is equal to one fratto the total number of words of text\r\n                        valTerm = new float[3];\r\n                        valTotTerm = new float[1];\r\n                        valTerm[0] = (float) 1 / toIterate.length;\r\n                        valTotTerm[0] = (float) 1 / toIterate.length;\r\n                    }\r\n                    // save the values calculated in the table of terms of the category analyzed\r\n                    list.setTermine(toIterate[k], valTotTerm);\r\n                    list.getCategoria(elencoCategorie[i]).addTermine(toIterate[k], valTerm);\r\n                    if (list.getMaxDist() < valTotTerm[0])\r\n                        list.setMaxDist(valTotTerm[0]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (String CategoryName : list.Categorie()) {\r\n        // for each category\r\n        // is preflushed the table of terms\r\n        Hashtable<String, float[]> terminiCategoria = list.getCategoria(CategoryName).getTermini();\r\n        // all the terms are analyzed in the table of loaded terms\r\n        for (Enumeration<String> enumTerm = terminiCategoria.keys(); enumTerm.hasMoreElements(); ) {\r\n            // is effattuato calculating bearing and distance\r\n            String term = enumTerm.nextElement();\r\n            float[] val = terminiCategoria.get(term);\r\n            val[1] = distance(term, list.getCategoria(CategoryName), list.getTotTermini());\r\n            val[2] = relevance(val[1], list.getMaxDist());\r\n        }\r\n        // data is stored in the table of the terms of the class\r\n        list.getCategoria(CategoryName).setTermini(terminiCategoria);\r\n    }\r\n    try {\r\n        // writing the results of operations on files\r\n        elencoOut.writeObject(list);\r\n    } catch (Exception e) {\r\n        throw new RemoteException(\"Error writing file\");\r\n    }\r\n}]",
                "hasComment": true,
                "hasInnerComment": true,
                "signature": "public static void training()",
                "comments": "Optional[/**\r\n * Method used to create the knowledge base\r\n *\r\n * @throws RemoteException\r\n */\r\n]",
                "innerComments": "Optional[[// Of categories to be analyzed\r\n, // elencoCategorie[3] = \"\";\r\n, // array containing names\r\n, // Knowledge base\r\n, // Try to create the file\r\n, // for each category\r\n, // Create a new object of type Category, which will contain all\r\n, // If the inclusion of the category in the table of categories\r\n, // Not successful\r\n, // You try to read from the folder containing the lyrics of a\r\n, // Category\r\n, // Category data to be analyzed\r\n, // We throw an exception\r\n, // 100 sample test\r\n, // Path of the folder category\r\n, // Try to read the file ith\r\n, // If the file does not exist it continues execution from\r\n, // File i +1\r\n, // System.out.println(\"Error on file\" + path);\r\n, // Read the text file line by line\r\n, // If the term is present in the table of terms\r\n, // For each end of the line\r\n, // Undefined terms\r\n, // remove the effect\r\n, // Relevant\r\n, // The class analyzed\r\n, // Its frequency is equal to the value stored in\r\n, // Table plus one fratto the total number of\r\n, // Terms of the text\r\n, // otherwise it is equal to one fratto the total number of words of text\r\n, // save the values calculated in the table of terms of the category analyzed\r\n, // for each category\r\n, // is preflushed the table of terms\r\n, // all the terms are analyzed in the table of loaded terms\r\n, // is effattuato calculating bearing and distance\r\n, // data is stored in the table of the terms of the class\r\n, // writing the results of operations on files\r\n]]",
                "generated_comment": "/**\n * This method is responsible for training the knowledge base by analyzing text files in different categories.\n * It creates a list of categories to be analyzed and reads text files to extract relevant terms and calculate their relevance.\n * \n * @throws RemoteException if there is an error creating or writing the file\n */\npublic static void training() {\n    // array containing names of categories\n    String[] elencoCategorie = new String[4];\n    \n    // Knowledge base\n    ElencoCategorie list = new ElencoCategorie();\n    ObjectOutputStream elencoOut;\n    \n    try {\n        // Try to create the file\n        elencoOut = createFile(\"kb.sbt\");\n    } catch (Exception e) {\n        throw new RemoteException(\"Error creating file kb.sbt\");\n    }\n    \n    // Iterate through each category\n    for (int i = 0; i < 3; i++) {\n        // Create a new Category object for each category\n        Category toPutCat = new Category(elencoCategorie[i]);\n        \n        // If adding the category to the list is not successful, throw an exception\n        if (!list.addCategoria(elencoCategorie[i], toPutCat)) {\n            throw new RemoteException(\"Error creating data of category \" + elencoCategorie[i]);\n        }\n        \n        // Read text files for the category\n        for (Integer j = 1; j <= 100; j++) {\n            // Path of the folder for the category\n            String path = \"kb/\" + elencoCategorie[i] + \"/\" + j.toString();\n            \n            // Try to read the file\n            FileReader testoReader;\n            try {\n                testoReader = new FileReader(path);\n            } catch (FileNotFoundException e) {\n                continue;\n            }\n            \n            // Process the text file\n            Scanner testoScanner = new Scanner(testoReader);\n            while (testoScanner.hasNextLine()) {\n                // Read the text file line by line\n                String txt = testoScanner.nextLine();\n                // Process and split the text\n                String[] toIterate = txt.split(\" \");\n                \n                // Analyze each term in the text\n                for (int k = 0; k < toIterate.length; k++) {\n                    // Process and calculate relevance of each term\n                    // Save the calculated values in the category's term table\n                }\n            }\n        }\n    }\n    \n    // Calculate relevance for each term in each category\n    for (String CategoryName : list.Categorie()) {\n        // Process and calculate relevance for each term in the category\n        // Store the calculated values in the category's term table\n    }\n    \n    try {\n        // Write the results to the file\n        elencoOut.writeObject(list);\n    } catch (Exception e) {\n        throw new RemoteException(\"Error writing file\");\n    }\n}\n*/"
            }
        ],
        "constructors": [],
        "signature": "Fuzzy",
        "variables": [],
        "generated_class_comment": "/**\n * Fuzzy class implements a set of methods for fuzzy logic calculations and text categorization.\n * It provides functionality for calculating relevance, distance, similarity, T-Norm, S-Norm, membership,\n * and training a knowledge base for text categorization.\n * \n * The class includes methods for:\n * - Calculating the relevance of a term in a category based on distance and maximum distance.\n * - Calculating the distance between a term and a category using frequency values.\n * - Calculating the distance of a term from a category for training purposes.\n * - Implementing T-Norm and S-Norm functions for fuzzy logic operations.\n * - Calculating the similarity between two sets of float arrays using T-Norm and S-Norm.\n * - Calculating the membership value of a similarity score based on the maximum similarity score.\n * - Processing text by removing special characters and converting all letters to lowercase.\n * - Determining the category of a given text based on frequency, relevance, and membership of terms.\n * - Finding the category with the maximum degree of membership in a given Hashtable.\n * - Checking if a key exists in a provided Hashtable.\n * - Opening and reading a knowledge base file for text categorization.\n * - Creating a new ObjectOutputStream for writing to a file specified by the given path.\n * - Training the knowledge base by analyzing text files in different categories and extracting relevant terms.\n * \n * This class serves as a comprehensive tool for implementing fuzzy logic operations and text categorization algorithms.\n */\n*/"
    }
]