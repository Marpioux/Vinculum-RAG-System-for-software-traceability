{
    "Fuzzy": [
        {
            "parentClass": "Fuzzy",
            "name": "relevance",
            "sourceCode": "private static float relevance(float distance, float pMaxDist) {\r\n        return (distance / pMaxDist);\r\n    }"
        },
        {
            "parentClass": "Fuzzy",
            "name": "distance",
            "sourceCode": "private static float distance(String pTermine,\r\n                                   Hashtable<String, float[]> pTotTermini, float frequenzaTesto,\r\n                                   Category pCategoria) {\r\n\r\n        // The first variable tracks the frequency of a term\r\n        // Relating to a category\r\n        // The second keeps track of frequency for all\r\n        // Categories\r\n        float[] frequenzaCategoria = new float[3], frequenzaTotale = new float[3];\r\n\r\n        if (pCategoria.esisteTermine(pTermine)) { // if the term is\r\n            // In category\r\n            // Its frequency in this category is equal to the frequency\r\n            // KnowledgeBase\r\n            // More frequency in the search text\r\n            frequenzaCategoria = pCategoria.getVal(pTermine);\r\n            frequenzaCategoria[0] += frequenzaTesto;\r\n        } else {\r\n            // Otherwise it is equal to the frequency of the term in the text\r\n            // Analyzed\r\n            frequenzaCategoria[0] = frequenzaTesto;\r\n        }\r\n        \r\n        if (pTotTermini.get(pTermine) != null) { // if the term exists in\r\n            // Table of the total time\r\n            frequenzaTotale = pTotTermini.get(pTermine); // Get the value\r\n\r\n            frequenzaTotale[0] += frequenzaTesto; // the total frequency is given\r\n            // Frequency in the text\r\n            // Analyzed\r\n            // Plus any frequency stored in memory in the table\r\n            // Total time\r\n        }\r\n\r\n        return (frequenzaCategoria[0] / frequenzaTotale[0]); // distance is\r\n        // Equal to\r\n        // Frequency in\r\n        // Category\r\n        // The total frequency\r\n    }"
        },
        {
            "parentClass": "Fuzzy",
            "name": "distance",
            "sourceCode": "private static float distance(String pTermine,\r\n                                   Hashtable<String, float[]> pTotTermini, float frequenzaTesto,\r\n                                   Category pCategoria) {\r\n\r\n        // The first variable tracks the frequency of a term\r\n        // Relating to a category\r\n        // The second keeps track of frequency for all\r\n        // Categories\r\n        float[] frequenzaCategoria = new float[3], frequenzaTotale = new float[3];\r\n\r\n        if (pCategoria.esisteTermine(pTermine)) { // if the term is\r\n            // In category\r\n            // Its frequency in this category is equal to the frequency\r\n            // KnowledgeBase\r\n            // More frequency in the search text\r\n            frequenzaCategoria = pCategoria.getVal(pTermine);\r\n            frequenzaCategoria[0] += frequenzaTesto;\r\n        } else {\r\n            // Otherwise it is equal to the frequency of the term in the text\r\n            // Analyzed\r\n            frequenzaCategoria[0] = frequenzaTesto;\r\n        }\r\n        \r\n        if (pTotTermini.get(pTermine) != null) { // if the term exists in\r\n            // Table of the total time\r\n            frequenzaTotale = pTotTermini.get(pTermine); // Get the value\r\n\r\n            frequenzaTotale[0] += frequenzaTesto; // the total frequency is given\r\n            // Frequency in the text\r\n            // Analyzed\r\n            // Plus any frequency stored in memory in the table\r\n            // Total time\r\n        }\r\n\r\n        return (frequenzaCategoria[0] / frequenzaTotale[0]); // distance is\r\n        // Equal to\r\n        // Frequency in\r\n        // Category\r\n        // The total frequency\r\n    }"
        },
        {
            "parentClass": "Fuzzy",
            "name": "tNorm",
            "sourceCode": "private static float tNorm(float a, float b) {\r\n        return ((a * b) / ((2 - ((a + b) - (a * b)))));\r\n        // Return Math.min(a, b);\r\n        // Return a * b;\r\n        // Return Math.max(0, a + b - 1);\r\n    }"
        },
        {
            "parentClass": "Fuzzy",
            "name": "sNorm",
            "sourceCode": "private static float sNorm(float a, float b) {\r\n        return ((a + b) / (1 + a * b));\r\n        // Return Math.max(a, b);\r\n        // Return (a + b - (a * b));\r\n        // Return Math.min(1, a + b);\r\n    }"
        },
        {
            "parentClass": "Fuzzy",
            "name": "similarity",
            "sourceCode": "private static float similarity(Hashtable<String, float[]> pTermini) {\r\n        float sum = 0; // return value\r\n\r\n        for (float[] val : pTermini.values()) { // for all elements of\r\n            // Table\r\n            sum += (tNorm(val[1], val[0])) / (sNorm(val[1], val[0])); // performs\r\n            // Sum of the values given by the division of function T-Norm\r\n            // With the function S-Norm made\r\n            // Between relevance and belonging\r\n        }\r\n\r\n        return sum;\r\n    }"
        },
        {
            "parentClass": "Fuzzy",
            "name": "membership",
            "sourceCode": "private static float membership(float val, float maxSimilarity) {\r\n        return (val / maxSimilarity);\r\n    }"
        },
        {
            "parentClass": "Fuzzy",
            "name": "replaceAndLower",
            "sourceCode": "private static String replaceAndLower(String pStr) {\r\n        pStr = pStr.toLowerCase();\r\n        pStr = pStr.replace(\",\", \"\");\r\n        pStr = pStr.replace(\".\", \"\");\r\n        pStr = pStr.replace(\"!\", \"\");\r\n        pStr = pStr.replace(\"?\", \"\");\r\n        pStr = pStr.replace(\"'\", \"\");\r\n\r\n        return pStr;\r\n    }"
        },
        {
            "parentClass": "Fuzzy",
            "name": "calcolaCategoria",
            "sourceCode": "public static String calcolaCategoria(String pDescrizione) throws RemoteException {\r\n        if ((pDescrizione == null) || (pDescrizione.equals(\"\")))\r\n            return \"NULL\";\r\n        String text = pDescrizione;\r\n        // Table of terms associated with the text portion. Will contain\r\n        // Values of frequency, relevance, membership for each term\r\n        Hashtable<String, float[]> datiTesto = new Hashtable<>();\r\n        // Table of categories, each category will contain the value of\r\n        // Similarity and belonging Text\r\n        Hashtable<String, float[]> testoCategoria = new Hashtable<>();\r\n        text = replaceAndLower(text); // delete characters and special\r\n        // Returns the text by replacing\r\n        // Uppercase with lowercase\r\n        String[] testoSplit = text.split(\" \");\r\n        for (int i = 0; i < testoSplit.length; i++) { // For each end of the text\r\n            float[] toPut = new float[3]; // value to assign to the string\r\n            // In the hash table\r\n            float[] valTmp; // temporary variable containing the values\r\n            // Associated with the string if it already exists in the hash table\r\n            // If the string is present in the table picks up the values\r\n            // And increases by saving them in toPut\r\n            // Otherwise initialize the new string with frequency = 1\r\n            if (testoSplit[i].length() <= 3) // delete undefined terms\r\n                // As important, the inter ...\r\n                continue;\r\n            if (exists(testoSplit[i], datiTesto)) { // if the time analyzed\r\n                // Is present in table the terms of the analyzed text\r\n                // We get the value of frequency in the table and there\r\n                // Adds one\r\n                valTmp = datiTesto.get(testoSplit[i]);\r\n                toPut[0] = valTmp[0];\r\n                toPut[0] += (float) 1 / testoSplit.length;\r\n            } else {\r\n                toPut[0] = (float) 1 / testoSplit.length; // Otherwise initialize the value of frequency to a\r\n                // Fratto, the total number of terms (relative frequency)\r\n            }\r\n            // Insert the new entry in the table\r\n            // System.out.println(toPut[0]);\r\n            datiTesto.put(testoSplit[i], toPut);\r\n        }\r\n\r\n        // You try to open the knowledge base\r\n        ElencoCategorie list;\r\n        try {\r\n            list = apriElenco();\r\n        } catch (ClassNotFoundException e) { // error opening file kb.sbt\r\n            throw new RemoteException(\"The knowledge base is missing or corrupt\");\r\n        } catch (Exception e) {\r\n            throw new RemoteException(\"The knowledge base is missing or corrupt\");\r\n        }\r\n\r\n        // Is taken from the base of knowledge to the table of total time\r\n        Hashtable<String, float[]> totTermini = list.getTotTermini();\r\n        float maxSimilarity = -1; // holds the value of maximum similarity\r\n        for (String CategoryName : list.Categorie()) { // For all the categories in the knowledge base\r\n            float[] toPut = new float[3]; // value to assign to the string\r\n            // In the hash table\r\n            for (Enumeration<String> val = datiTesto.keys(); val.hasMoreElements();) { // For all elements of the table of the terms of the text\r\n                String term = val.nextElement();\r\n                // We get the value of a term\r\n                float[] tmp = datiTesto.get(term);\r\n                // Calculate range and bearing\r\n                tmp[1] = distance(term, totTermini, tmp[0], list.getCategoria(CategoryName));\r\n                tmp[2] = relevance(tmp[1], list.getMaxDist());\r\n                datiTesto.put(term, tmp);\r\n            }\r\n            // We calculate the similarity Once the analysis\r\n            // All the terms in a category\r\n            toPut[0] = similarity(datiTesto);\r\n            testoCategoria.put(CategoryName, toPut);\r\n            if (maxSimilarity < toPut[0]) { // we update the value of maximum\r\n                // If necessary similarity\r\n                maxSimilarity = toPut[0];\r\n            }\r\n        }\r\n\r\n        for (String CategoryName : list.Categorie()) { // For each category\r\n            // We get the value of similarity of the text with the category\r\n            // Analyzed\r\n            float[] tmp = testoCategoria.get(CategoryName);\r\n            tmp[1] = membership(tmp[0], maxSimilarity); // we calculate\r\n            // Membership\r\n            // Text to the similarity\r\n            testoCategoria.put(CategoryName, tmp); // save everything in\r\n            // Category table\r\n        }\r\n\r\n        return maxAppartenenza(testoCategoria); // returns the name output\r\n        // Category\r\n        // With the maximum degree of membership\r\n    }"
        },
        {
            "parentClass": "Fuzzy",
            "name": "maxAppartenenza",
            "sourceCode": "private static String maxAppartenenza(Hashtable<String, float[]> pTestoCategoria) {\r\n        String toReturn = null; // return value\r\n        float max = -1; // Maximum value of membership\r\n\r\n        for (Enumeration<String> elm = pTestoCategoria.keys(); elm.hasMoreElements();) { // For all categories of the table of categories of text\r\n            String category = elm.nextElement();\r\n            // Values are taken of similarity and belonging associated with\r\n            // Category\r\n            float[] tmp = pTestoCategoria.get(category);\r\n            if (tmp[1] > max) { // If the degree of membership affiliation just uploaded\r\n                // Is greater than the previous update data max and toReturn\r\n                toReturn = category;\r\n                max = tmp[1];\r\n            }\r\n        }\r\n        return toReturn;\r\n    }"
        },
        {
            "parentClass": "Fuzzy",
            "name": "exists",
            "sourceCode": "private static boolean exists(String pStr, Hashtable<String, float[]> pTable) {\r\n        try {\r\n            if (pTable.get(pStr) != null)\r\n                return true;\r\n        } catch (NullPointerException e) {\r\n            return false;\r\n        }\r\n\r\n        return false;\r\n    }"
        },
        {
            "parentClass": "Fuzzy",
            "name": "apriElenco",
            "sourceCode": "private static ElencoCategorie apriElenco() throws IOException, ClassNotFoundException {\r\n        File kBase = new File(\"kb.sbt\"); // you open the file kb.sbt\r\n        FileInputStream kBaseStream = new FileInputStream(kBase); // creates\r\n        // A stream with the file\r\n        ObjectInputStream kBaseObj = new ObjectInputStream(kBaseStream); // create a stream object with the file\r\n        ElencoCategorie toReturn;\r\n\r\n        toReturn = (ElencoCategorie) kBaseObj.readObject(); // Object is extracted and saved in the file returned in output\r\n        return toReturn;\r\n    }"
        },
        {
            "parentClass": "Fuzzy",
            "name": "createFile",
            "sourceCode": "private static ObjectOutputStream createFile(String path) throws IOException {\r\n        ObjectOutputStream toReturn;\r\n        File f = new File(path); // file is created\r\n        if (f.exists())\r\n            f.delete();\r\n\r\n        FileOutputStream fout = new FileOutputStream(path);\r\n        toReturn = new ObjectOutputStream(fout); // create the stream\r\n\r\n        return toReturn;\r\n    }"
        },
        {
            "parentClass": "Fuzzy",
            "name": "training",
            "sourceCode": "public static void training() throws RemoteException {\r\n        String[] elencoCategorie = new String[4]; // array containing names\r\n        // Of categories to be analyzed\r\n        // Knowledge base\r\n        ElencoCategorie list = new ElencoCategorie();\r\n\r\n        ObjectOutputStream elencoOut;\r\n        try {\r\n            // Try to create the file\r\n            elencoOut = createFile(\"kb.sbt\");\r\n        } catch (Exception e) {\r\n            throw new RemoteException(\"Error creating file kb.sbt\");\r\n        }\r\n\r\n        elencoCategorie[0] = \"art\";\r\n        elencoCategorie[1] = \"cinema\";\r\n        elencoCategorie[2] = \"sport\";\r\n        // elencoCategorie[3] = \"\";\r\n\r\n        for (int i = 0; i < 3; i++) { // for each category\r\n            // Create a new object of type Category, which will contain all\r\n            // Category data to be analyzed\r\n            Category toPutCat = new Category(elencoCategorie[i]);\r\n            // If the inclusion of the category in the table of categories\r\n            // Not successful\r\n            // We throw an exception\r\n            if (!list.addCategoria(elencoCategorie[i], toPutCat)) {\r\n                throw new RemoteException(\"Error creating data of category \" + elencoCategorie[i]);\r\n            }\r\n            // You try to read from the folder containing the lyrics of a\r\n            // Category\r\n            // 100 sample test\r\n            for (Integer j = 1; j <= 100; j++) {\r\n                // Path of the folder category\r\n                String path = \"kb/\" + elencoCategorie[i] + \"/\" + j.toString();\r\n                // Try to read the file ith\r\n                FileReader testoReader;\r\n                try {\r\n                    testoReader = new FileReader(path);\r\n                } catch (FileNotFoundException e) {\r\n                    // If the file does not exist it continues execution from\r\n                    // File i +1\r\n                    // System.out.println(\"Error on file\" + path);\r\n                    continue;\r\n                }\r\n                Scanner testoScanner = new Scanner(testoReader);\r\n                while (testoScanner.hasNextLine()) {\r\n                    // Read the text file line by line\r\n                    String txt = testoScanner.nextLine();\r\n                    txt = replaceAndLower(txt);\r\n                    String[] toIterate = txt.split(\" \");\r\n                    for (int k = 0; k < toIterate.length; k++) { // For each end of the line\r\n                        if (toIterate[k].length() <= 3) // remove the effect\r\n                            // Undefined terms\r\n                            // Relevant\r\n                            continue;\r\n                        float[] valTerm, valTotTerm;\r\n                        // If the term is present in the table of terms\r\n                        // The class analyzed\r\n                        if (list.getCategoria(elencoCategorie[i]).esisteTermine(toIterate[k])) {\r\n                            // Its frequency is equal to the value stored in\r\n                            // Table plus one fratto the total number of\r\n                            // Terms of the text\r\n                            valTerm = list.getCategoria(elencoCategorie[i]).getVal(toIterate[k]);\r\n                            valTerm[0] += (float) 1 / toIterate.length;\r\n                            valTotTerm = list.getTermine(toIterate[k]);\r\n                            valTotTerm[0] += (float) 1 / toIterate.length;\r\n                        } else {\r\n                            // otherwise it is equal to one fratto the total number of words of text\r\n                            valTerm = new float[3];\r\n                            valTotTerm = new float[1];\r\n                            valTerm[0] = (float) 1 / toIterate.length;\r\n                            valTotTerm[0] = (float) 1 / toIterate.length;\r\n                        }\r\n                        // save the values calculated in the table of terms of the category analyzed\r\n                        list.setTermine(toIterate[k], valTotTerm);\r\n                        list.getCategoria(elencoCategorie[i]).addTermine(toIterate[k], valTerm);\r\n                        if (list.getMaxDist() < valTotTerm[0])\r\n                            list.setMaxDist(valTotTerm[0]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (String CategoryName : list.Categorie()) { // for each category\r\n            // is preflushed the table of terms\r\n            Hashtable<String, float[]> terminiCategoria = list.getCategoria(CategoryName).getTermini();\r\n\r\n            // all the terms are analyzed in the table of loaded terms\r\n            for (Enumeration<String> enumTerm = terminiCategoria.keys(); enumTerm.hasMoreElements();) {\r\n                // is effattuato calculating bearing and distance\r\n                String term = enumTerm.nextElement();\r\n                float[] val = terminiCategoria.get(term);\r\n                val[1] = distance(term, list.getCategoria(CategoryName), list.getTotTermini());\r\n                val[2] = relevance(val[1], list.getMaxDist());\r\n            }\r\n            // data is stored in the table of the terms of the class\r\n            list.getCategoria(CategoryName).setTermini(terminiCategoria);\r\n        }\r\n        try {\r\n            // writing the results of operations on files\r\n            elencoOut.writeObject(list);\r\n        } catch (Exception e) {\r\n            throw new RemoteException(\"Error writing file\");\r\n        }\r\n    }"
        }
    ]
}